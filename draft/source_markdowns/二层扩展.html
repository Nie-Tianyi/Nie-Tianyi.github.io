<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>nty的技术博客 | nty的技术博客</title><meta name="author" content="nty"><meta name="copyright" content="nty"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="尽管以太坊大幅提高了出块时间（与比特币相比），将出块时间从比特币的10min一个区块提高到了15s一个区块，处理交易的速度从比特币的3.4Tps升级到了15Tps，但是其处理交易的速度仍是限制区块链应用发展主要制约。特别是每当以太坊网络内出现火爆的DApp时，以太坊网络都会出现严重拥堵。因此，很多学者和从业者都贡献了不同的方案以提高以太坊主网处理交易的速度，特别是处理智能合约相关交易的速度。我们把">
<meta property="og:type" content="website">
<meta property="og:title" content="nty的技术博客">
<meta property="og:url" content="https://nie-tianyi.github.io/draft/source_markdowns/%E4%BA%8C%E5%B1%82%E6%89%A9%E5%B1%95.html">
<meta property="og:site_name" content="nty的技术博客">
<meta property="og:description" content="尽管以太坊大幅提高了出块时间（与比特币相比），将出块时间从比特币的10min一个区块提高到了15s一个区块，处理交易的速度从比特币的3.4Tps升级到了15Tps，但是其处理交易的速度仍是限制区块链应用发展主要制约。特别是每当以太坊网络内出现火爆的DApp时，以太坊网络都会出现严重拥堵。因此，很多学者和从业者都贡献了不同的方案以提高以太坊主网处理交易的速度，特别是处理智能合约相关交易的速度。我们把">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nie-tianyi.github.io/images/avatar.png">
<meta property="article:published_time" content="2025-09-16T17:12:00.220Z">
<meta property="article:modified_time" content="2025-09-16T17:01:23.880Z">
<meta property="article:author" content="nty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nie-tianyi.github.io/images/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nie-tianyi.github.io/draft/source_markdowns/%E4%BA%8C%E5%B1%82%E6%89%A9%E5%B1%95.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'nty的技术博客',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'page'
}</script><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div class="page" id="body-wrap"><header class="not-home-page" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">nty的技术博客</span></a></span><div id="menus"></div></nav><div id="page-site-info"><h1 id="site-title"></h1></div></header><main class="layout" id="content-inner"><div id="page"><div class="container" id="article-container"><p>尽管以太坊大幅提高了出块时间（与比特币相比），将出块时间从比特币的10min一个区块提高到了15s一个区块，处理交易的速度从比特币的3.4Tps升级到了15Tps，但是其处理交易的速度仍是限制区块链应用发展主要制约。特别是每当以太坊网络内出现火爆的DApp时，以太坊网络都会出现严重拥堵。因此，很多学者和从业者都贡献了不同的方案以提高以太坊主网处理交易的速度，特别是处理智能合约相关交易的速度。我们把这些方案统称为区块链的二层扩展。区块链行业对二层扩展的基本要求是需要保证区块链安全的情况下，提高区块链的可拓展性。现在实现二层扩展的主要思路是将大量计算工作转移到链下，最后将计算结果提交到链上保证其最终性。也有人认为侧链也是实现二层扩展的主要方式之一，但是另一些人认为侧链不能保证其自身安全性（例如侧链矿工较少，容易被攻击，从而影响到主链安全性），只有继承了主链安全性的侧链才能算作一个合格的二层扩展方案（例如在Polkadot中，侧链的区块都要放到中继链上，让中继链内的验证者验证）。</p>
<h2 id="支付通道">支付通道</h2>
<p>支付通道利用密码学手段，例如哈希时间锁，来保证链下交易的安全性。链下交易，即通道内发生的所有交易都不会记录在区块链上。通道内有一份自己的临时账本记录交易的结果。只有当支付通道关闭时，才会将临时账本内的结果记录在区块链上，保证交易结果的最终性。常见的支付通道的例子有比特币的闪电网络，以及以太坊的雷电网络。</p>
<h3 id="比特币闪电网络">比特币闪电网络</h3>
<h4 id="通道建立">通道建立</h4>
<p>比特币闪电网络通过双向通道进行交易。交易的双方首先需要在将手中一定数量的比特币质押到一个多签的UTXO当中，然后双方再在线下进行多笔交易，最后在关闭通道时，将交易的结果更新到区块链上。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/45785720/1724667981012-622d1280-08f9-400a-8c67-8b94caa7716b.png" alt></p>
<p>通过比特币闪电网络进行交易的过程可以分为三个阶段，分别是通道的建立，在通到内交易，以及通道的关闭。建立通道的流程如下：</p>
<ol>
<li>A和B协商好草拟一条抵押交易 {输入： A=100，B=100，输出：A+B=200}，不签名输入，不广播。这里的A+B是多签，花费这个UXTO时必须A和B同时签名才行。</li>
<li>双方分别开始构建承诺交易（Commitment Transaction）。A构建交易CA = {输入：A+B=200，输出：A2+B=100,B=100}，其中A2是A的另外一个钱包；B构建CB = {输入：A+B=200，输出：A+B2=100,A=100}，其中B2是B的另外一个钱包。这里构建的所有交易都是不广播，不上链的。</li>
<li>双方构建退款交易（Refund Transaction）。RA = {输入：A2+B=100，输出：A=100，延时1000个区块}；RB = {输入：A+B2=100，输出：B=100，延时1000个区块}。这两个交易也是不广播，不上链的。</li>
<li>双方为对方的承诺交易和退款交易签名。（注意，这里承诺交易和退款交易也是不广播的）</li>
<li>双方签名抵押交易，广播抵押交易。</li>
</ol>
<p>此时双向支付通道就构建好了。注意，A和B构建的承诺交易的收款方都是对方，只有退款交易的收益人是自己。这意味着A和B任意一方向要将自己质押的钱取出来时，都需要先给对方还钱后，才能提款自己的余额。</p>
<h4 id="交易过程">交易过程</h4>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/45785720/1724667999285-80fd8f9c-6b4d-4b33-8ceb-7ea9cf083d3c.png" alt></p>
<p>当A和B在支付通道内交易时，例如现在，A给B支付10个比特币：</p>
<ol start="6">
<li>假设在通道内A给B支付10比特币，双方分别构建新的承诺交易。A构建的新承诺交易为CA1 = {输入：A+B=200，输出：A3+B=90,B=110}；B构建的新承诺交易为CB1 = {输入：A+B=200，输出：A+B3=110,A=90}。</li>
<li>双方分别构建新的退款交易。A构建的新的退款交易RA1 = {输入：A3+B=90，输出：A=90，延迟1000区块}；B构建的新的退款交易RB1 = {输入：A+B3=110，输出：B=110，延迟1000个区块}。</li>
<li>双方为对方的承诺交易和退款交易签名。</li>
<li>A将A2的私钥发给B。</li>
</ol>
<p>参与双向支付通道的双方可以在通道内进行多次交易，而不会给链上添加任何负担。假设A给B转账10个比特币后反悔了，她呢直接广播建立通道时创建的承诺交易CA和退款交易RA作弊吗？不能，因为在交易的最后，A将A2的私钥发给了B，如果此时A广播了上一轮的CA和RA，那么B就可以构建这样一条消息并签名：RA‘ = {输入：A2+B=100，输出：B=100}，将账户内所有余额转到自己账户，并且这笔交易会在RA之前执行，因为RA需要延时1000个区块执行。当然，这也引出了闪电网络的一个缺点，这样的反制手段只有在前一个交易后1000个区块的时间内有效。这意味着用户必须定时参与闪电网络的交易，才能保证自己钱包的安全。那么既然B有A2的私钥了，他可以把A账户的钱取走吗？这也是不行的，退款交易只有在承诺交易后才能生效，而承诺交易需要生效，则需要A的私钥。</p>
<h4 id="交易关闭">交易关闭</h4>
<p>当任何一方想要关闭这个双向支付通道、结束交易时，其可以广播手上的承诺交易和退款交易，这时账户上的余额就会被分别退回到A和B的账户内。例如上例中A在转账10个比特币后想要结束交易，其需要先广播承诺交易，此时110个比特币会被退回到B的账户内，然后A才能广播其退款交易，取回账户内剩余的90个比特币。</p>
<h4 id="组成网络">组成网络</h4>
<p>闪电网络不仅能实现点对点的链下交易，还能跨越多个节点，组成支付通道网络。例如：A和B之间有一个现成的通道，B和C之间有一个现成的通道，那么A可以通过B中继给C转账，而不用再建立一个支付通道。假设转账现金流为 A -&gt; B -&gt; C，那么在HTLC的帮助下，我们可以通过以下步骤实现中继转账：</p>
<ol>
<li>C生成随机数R，并计算H（R）。</li>
<li>C将H（R）发送给A。</li>
<li>A 创建一个HTLC，通过B发起支付，并指定B只有在提供R时才能获取相应资金。</li>
<li>B 创建HTLC，向C转账，并且获取到R。</li>
<li>C 提供 R，收到B的转账。</li>
<li>B获得R，收到A的转账。</li>
<li>A 完成支付，C收到款项，B收取一点点中介费。</li>
</ol>
<p>闪电网络在实现时，时间锁时到期时间通常会是递减的，假设A需要给D转账，经过 A-&gt;B-&gt;C-&gt;D。那么AB之间的HTLC时限通常被设置为3天，BC之间是两天，CD之间是一天。</p>
<h2 id="主链-子链架构">主链-子链架构</h2>
<p>主链-子链架构是以太坊扩容的另一种方式。这种方式通过将计算转移到另一条区块链（子链）上来减少主链（例如以太坊）的网络中的负担。子链是一条单独的区块链，这条区块链有自己独立的验证者和网络，并且有自己的虚拟机，可以执行智能合约。主链和子链通过一个部署在主链上的智能合约实现资产的互相转移——例如，现在有一条子链企鹅链，子链上使用的代币为Q币。此时如果A想要转移资产到子链，A在以太坊上给专门转移资产到子链的智能合约转账一笔以太币，此时A转账的以太币会被锁定，然后子链上释放一笔同等金额Q币给</p>
<p>尽管这样的方式听起来很像侧链以及双向锚定协议，但是主链-子链架构和侧链相比，还是有很大的不同。例如，在上例中，整个企鹅链的验证者可以只有一个实体——假设在这里是腾讯公司，并且我们把这个实体叫做Operator，这跟现实中充Q币的例子是相似的——那么如果Operator作恶怎么办，如果腾讯公司尝试贪污掉A的以太币怎么办？Plasma为这种情况设置了一条完整的协议，帮助用户A在主链帐取回自己的以太币，维护自己的权益，这些在下面会讲到。而在侧链中，主链上没有专门维护侧链用户权益的机制，侧链也不会只有一个验证者，这样的链是不安全的，不会有人信任的。主链-子链协议与侧链协议的不同之处还有，在主链-子链协议中，子链需要定时在主链上更新子链的状态，而这在双向锚定协议中式不需要的。总的来说，主链-子链协议中，两条链有明确的，子链和主链是从属关系，子链的安全性是与主链有关的；而在侧链中，两条链是平行的关系，两条链的安全性是独立的。</p>
<p>由于在主链-子链协议中，子链可以只有一个验证者（或者很少几个验证者），因此执行交易的速度可以非常快（这相当于是一种中心化的方式了）。这样就相当于加速的网络内交易处理的速度，扩容了网络。主链-子链协议最早出现在以太坊的二层扩展Plasma中，曾是以太坊社区主力发展的二层扩展的方案。但是后来Plasma这种扩展方案逐渐被卷叠（Rollup）二层扩展方案所取代。</p>
<h3 id="Plasma">Plasma</h3>
<p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/Blockchains-of-blockchain.png" alt></p>
<p>在Plasma中，任何人和实体都可以创建一条依附于以太坊的子链。子链是 Plasma 框架中独立运行的小型区块链，主要处理用户的交易。每个子链都有自己的一套规则和共识算法，可以与主链的共识机制不同。子链的状态变化（如交易）最终会通过默克尔树（Merkle Tree）等数据结构提交到主链进行记录和验证。</p>
<p>在主链-子链协议中，主链（例如以太坊上）创一个一个智能合约，这些智能合约内规定了子链的创建规则，状态转换规则（例如如何处理Operator作恶），也记录了子链的状态，与子链交互的通信媒介。Plasma规定所有的数字资产（例如代币或者NFT）必须在主链上创建，再转移到子链。并且子链上的operator需要定期将子链的状态更新证明提交到主链。</p>
<p>子链的所有交易最终都会在主链上通过定期提交的方式得到验证。这种提交通常以“块”的形式进行，并通过默克尔根（Merkle Root）将多个交易的哈希值聚合后提交至主链。主链不需要处理每笔交易的详细内容，而是只需要记录和验证这些提交的默克尔根。<font style="color:rgb(51, 51, 51);">当有恶意行为发生时，子链网络中的所有用户都可以向主链提交防伪证明，证明成立后，含有恶意交易的区块将被回滚。</font></p>
<h4 id="存款">存款</h4>
<p>存款是指将主链资产转移到子链的过程。用户在存款时需要向主链上的Plasma合约发送以太币或者其他由ERC20合约创建的虚拟币。Plasma合约在收到交易后会锁定该笔交易，然后再子链上创建根交易数额一样的一笔交易，当该笔交易被打包进区块后，用户就可以在子链上使用这笔资产了。</p>
<h4 id="font-style-color-rgb-51-51-51-欺诈证明（Fraud-Proof）-font"><font style="color:rgb(51, 51, 51);">欺诈证明（Fraud Proof）</font></h4>
<p><img src="https://raw.githubusercontent.com/gitferry/mastering-ethereum/master/Plasma-in-depth/images/Fraud-proof.png" alt></p>
<p>Plasma 的一个关键设计之一就是允许用户构造防伪证明（Fraud Proof，也有翻译欺诈证明）。防伪证明的意义在于只要发布区块的节点构造了含有恶意交易的区块，那么就要承担被惩罚的风险。每当新的区块被提交到主链上时，会留出一段时间给用户检举揭发，提交防伪证明，如果在这段时间内没有证明被提交，则认为新的区块被验证合法。如果有防伪证明检测到区块中存在恶意交易，则该区块将被舍弃，回滚到上一个被验证合法的区块。</p>
<h4 id="font-style-color-rgb-51-51-51-取款-font"><font style="color:rgb(51, 51, 51);">取款</font></h4>
<p><font style="color:rgb(51, 51, 51);">在 Plasma 中，如果用户想从子链上取出资产，他们需要向主链上的 Plasma 智能合约发送一笔已签名的取款交易。取款的金额可以包括多个输出（即未花费的交易输出，UTXO 模型），但这些输出必须全部来自同一个子链，并且每个输出的余额必须全部取出，不能部分提取。此外，取款金额的一部分会作为押金，防止用户进行恶意操作。如果在后续的验证过程中发现取款有问题，这部分押金将被没收。</font></p>
<p><font style="color:rgb(51, 51, 51);">当用户提交取款请求后，需要经历一个“争议期”（Challenge Period）。在这个争议期内，其他节点有机会对取款提出异议，提供证据证明这笔取款中的部分或全部资金已经被花费或不符合条件。如果有节点成功提出争议，那么这笔取款将会被取消，并且取款时提交的押金将被扣除，作为对提交虚假取款请求的惩罚。</font></p>
<p><font style="color:rgb(51, 51, 51);">在争议期结束后，如果没有任何争议被提出，则认为这笔取款操作成立，用户可以顺利地将子链上的资产取回到主链。需要注意的是，取款操作通常按“先来后到”的顺序执行，以确保所有早期的取款操作能够优先完成。</font></p>
<h4 id="font-style-color-rgb-51-51-51-快速取款-font"><font style="color:rgb(51, 51, 51);">快速取款</font></h4>
<p><font style="color:rgb(51, 51, 51);">快速取款（Fast Withdrawal）是一种加速提取资产的方法。与常规取款相比，快速取款引入了一个称为流动性提供者（Liquidity Provider，简称 LP）的中间人。如果用户不想等待长时间的争议期（通常至少需要一周），他们可以选择通过 LP 进行快速取款。这个过程只需要一个交易确认的时间，但用户需要支付给 LP 一定的费用作为代价。</font></p>
<p><font style="color:rgb(51, 51, 51);">为了实现快速取款，取款方和 LP 可以利用一个流动合约（liquidity contract）。假设 Alice 想要快速提取 10 以太币从子链转移到主链。她首先向流动合约发送 10 以太币的交易，这笔交易会被子链打包进区块中。当交易被确认后，Alice 可以调用流动合约中的一个退出函数，获得一个代表这笔资产的 token。然后，Bob 作为 LP，检查子链上的数据，确认 Alice 的取款没有问题后，同意以 9 以太币的价格购买这个 token。Alice 将 token 卖给 Bob，从而快速获得了 9 以太币，而 Bob 则赚取了 1 以太币的差价。需要注意的是，为了确保快速取款的安全性，LP 必须验证取款方的交易历史，因此前提是没有发生拜占庭攻击，如区块扣留攻击。</font></p>
<h4 id="font-style-color-rgb-51-51-51-批量取款-font"><font style="color:rgb(51, 51, 51);">批量取款</font></h4>
<p><font style="color:rgb(51, 51, 51);">当子链中发生拜占庭行为（例如，区块扣留攻击）时，将影响未来生成防伪证明的能力。因此，网络中的每个用户都有责任快速退出子链。尽管批量取款（Mass Withdrawal）不是唯一的选择，但当大量用户同时执行取款时，可能会导致主链拥塞，并消耗大量 gas。因此，在子链遭受攻击时，批量取款可能是更好的解决方案。</font></p>
<p><font style="color:rgb(51, 51, 51);">批量取款的操作方式会因采用的模型不同（UTXO 模型或账户模型）而有所差异。尽管目前关于批量取款的具体操作细节仍在研究中，但一般来说，当发生拜占庭行为时，用户可以协作执行批量取款。这时，一个节点将担任取款处理人（Exit Processor，简称 EP），负责管理当前的批量取款操作。EP 会构建一个位图（bitmap），记录哪些资产需要执行取款，并利用现有的区块数据检查每个取款的合法性。接着，EP 会构造一笔批量退出初始化交易（Mass Exit Initiation Transaction，MEIT），并将其发送到主链上。在 MEIT 被主链确认之前，每个用户都可以对这个交易提出异议。如果在争议期结束后没有异议被提出，MEIT 就会被主链确认，批量取款将成功完成。</font></p>
<h2 id="卷叠扩展（Rollup）">卷叠扩展（Rollup）</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/45785720/1724668075859-129ec3be-908f-482c-b78d-b96f99365751.png" alt></p>
<p><font style="color:rgb(51, 51, 51);">Rollup 是一种以太坊的二层扩展机制，其允许交易在一个单独的区块链上执行，执行完后将交易压缩打包提交回以太坊主链。同时以太坊主链上有一群验证者，负责验证子链提交上来的交易。这样既增加了以太坊交易处理的速度，也能让子链继承主链的安全性。这种方案跟侧链机制有些相像，但是本质上却完全不同。在侧链方案中，主链只记录侧链的总状态，主链也不验证侧链中的交易，因此，我们说再侧链方案中，侧链没有继承主链的安全性。Rollup方案来自于主链-子链方案，是对主链-子链方案的改进（事实上Rollup方案中的）。Rollup中，子链和Plasma中一样，拥有较大的自主性，其可以自己决定共识算法、出块速度这些基础机制。再Rollup中向子链转账的机制也和Plasma相同：首先用户需要给主链上的一个特定智能合约转账，然后才能在子链上使用这笔金额。需要注意的是，尽管在Rollup子链上交易的费用比主链上低很多，用户仍需要为在子链上执行的交易支付手续费，这个手续费通常是直接在主链上交易的万分之一上下。L2链上的交易并不具备最终性，只有被打包上L1链的交易才具有最终性，通常我们把L2链上这种半确定的状态叫做“瞬时最终性”。</font></p>
<h3 id="卷叠类型">卷叠类型</h3>
<p><font style="color:rgb(51, 51, 51);">Rollup根据在主链上验证子链提交交易方式的不同，可以分为Optimistic Rollup和ZK Rollup，Optimistic Rollup通过欺诈证明来保证子链执行结果的正确性，而ZK Rollup通过零知识证明来保证子链执行结果的正确性。目前Optimistic Rollup有更广泛的应用，而ZK Rollup应用较少。当前ZK Rollup由于技术的限制，还不支持在子链中部署智能合约，而Optimistic Rollup对智能合约的支持较好。但是Optimistic Rollup验证交易的成本较高，因此开发支持智能合约的ZK Rollup方案是现在二层扩展生态发展中的一个主要方向。</font></p>
<h3 id="乐观卷叠（Optimistic-Rollup）">乐观卷叠（Optimistic Rollup）</h3>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/45785720/1724667493790-d0eb3da4-e029-441c-9214-7e9f2adbc4a2.png" alt></p>
<p><font style="color:rgb(51, 51, 51);">Optimistic Rollup方案来自于一个假设：乐观 Rollup认为，提交到L1链上的交易中很少有人会作弊，因此当L2中的交易被打包上L1链时，L1不验证提交批次中的交易。同时链下有一群验证者，负责线下验证交易，如果发现可疑交易，则可以举报。举报成功后，该批次交易回滚，质疑者会获得奖赏，而提交该有问题批次的验证者会得到惩罚。为了保证链的安全，交易在被提交后一到两周后才能生效，这一到两周属于挑战期，验证者需要质押很大一笔钱，如果挑战期内有人发现他作弊，则保证金没收。这样的方案是现在唯一支持执行智能合约的Rollup方案，但是这个方案有两个缺点：一是交易锁定时间过长，用户需要等至少一周才能重新花费钱包中的钱；二是这样的假设有一个悖论：如果提交中很少有验证者作弊，则举报人会发现几乎无利可图，因此倾向于不验证；而如果提交过程中很多验证者作弊，则会产生大量回滚，导致整个Roll up方案几乎不可用。Optimism是实现Optimistic Rollup方案的一条子链。</font></p>
<h4 id="交互式欺诈证明">交互式欺诈证明</h4>
<p><font style="color:rgb(51, 51, 51);">交互式防伪证明允许一方（通常是验证者）在交互过程中发现并展示另一方（通常是欺诈者）存在欺诈行为的证据。  </font></p>
<ol>
<li><font style="color:rgb(51, 51, 51);">系统中的各方遵循预先定义的协议进行操作。这个协议通常规定了数据传输、交易验证、智能合约执行等具体步骤。当一方怀疑另一方没有遵守协议或存在欺诈行为时，交互式欺诈证明就会被触发。  </font></li>
<li><font style="color:rgb(51, 51, 51);">验证者向被怀疑的节点或参与方提出一个具体的挑战，通常是要求对方提供与协议一致的证明或计算结果。 如果对方无法提供正确的响应，或者响应中存在矛盾，这就表明可能存在欺诈行为。</font></li>
<li><font style="color:rgb(51, 51, 51);">  验证者将发现的欺诈证据公开或提交给一个第三方仲裁者（比如区块链网络上的智能合约）。一旦欺诈行为被证明，系统通常会执行预定的惩罚机制。惩罚可以包括经济处罚、节点信誉降低、或者在区块链上进行的其他制裁措施。  </font></li>
</ol>
<h4 id="font-style-color-rgb-51-51-51-非交互式欺诈证明-font"><font style="color:rgb(51, 51, 51);">非交互式欺诈证明</font></h4>
<p><font style="color:rgb(51, 51, 51);">非交互式防伪证明（Non-Interactive Proof of Fraud，NIPoF）是一种在无需多次交互的情况下证明欺诈行为的技术。它允许一方直接生成并提交欺诈证据，使其他方能够独立验证这些证据，从而判定是否存在欺诈行为。  </font></p>
<ol>
<li><font style="color:rgb(51, 51, 51);">系统中的各方遵循一套预先定义的规则和协议进行操作。这些规则包括交易验证、数据存储、智能合约执行等方面的要求。如果某方违反这些规则，另一方可以依据这些规则生成欺诈证明。 这份证明包含了被质疑的操作细节及其违反协议的具体内容。  </font></li>
<li><font style="color:rgb(51, 51, 51);">验证者（通常是整个网络或一个智能合约）可以通过公开的算法和数据独立验证这份欺诈证明的有效性。因为证明是非交互式的，一旦生成，就可以直接发布，无需来回的通信或互动。非交互式欺诈证明通常包括加密签名、哈希值等技术，以确保证明内容的完整性和真实性  </font></li>
<li><font style="color:rgb(51, 51, 51);"> 生成的欺诈证明可以直接发布到区块链或提交给智能合约。网络上的所有参与者或智能合约可以自动验证该证明，并执行相应的后续操作。如果欺诈行为被确认，智能合约可以自动执行惩罚措施，如罚没保证金、禁止参与等。  </font></li>
</ol>
<h4 id="Optimism">Optimism</h4>
<p><font style="color:rgb(51, 51, 51);">Optimism本身也是一条区块链，而且其机制和以太坊大致相同。其执行过程大致如下：</font></p>
<ol>
<li><font style="color:rgb(51, 51, 51);">在L2上执行交易，生成L2的本地状态树和树根。</font></li>
<li><font style="color:rgb(51, 51, 51);">每个交易执行后都会改变状态树以及状态树根，把每笔交易以及每个交易执行完后的状态树根对应起来，打包提交到L1。Optimism中，分为定序器和提议者，定序器（Sequencer，以太坊官方文档翻译为排序者）只负责提交交易，提议者计算、提交状态树根。还有一个 验证者，负责在L1上验证交易执行后状态的正确性。这就是所谓的欺诈证明，欺诈证明指在区块链中，我们假设所有交易都是正确的，除非有人提出挑战来证明某个交易或者区块是不合法的。</font></li>
<li><font style="color:rgb(51, 51, 51);"> L1上的验证者可以通过L1上的合约，重新执行交易内容，检查执行结果是否有问题。L1上的验证者重新执行交易的过程叫做 重放。</font></li>
</ol>
<p><font style="color:rgb(51, 51, 51);">在Optimistic Rollup中，不需要太多验证者，目前Optimism中只有一个 验证者，其负责生成区块，也叫定序器。那么我们如何防止定序器作恶，故意破坏网络？由于整个子链中一个定序器一个验证者，因此其可以拒绝执行某笔交易，但是拒绝执行交易会引发网络内的信任崩塌，因此网络内的用户会大量推出网络。定序器还可以执行交易后提交错误的执行结果，但是这样的行为有可能会被L1上的验证者发现，这时定序器会损失一大笔押金。</font></p>
<h4 id="OVM">OVM</h4>
<p><font style="color:rgb(51, 51, 51);">为了保持一致性，L2上的执行环境和L1上的执行环境要保持一致性，执行环境可以分为：虚拟机，合约，交易，和状态。为了在L1上获得和L2一样的执行环境，我们引入OVM。OVM是一个智能合约，L1上重放时，L1上的智能合约不再直接从主链上获取环境信息，而是从OVM上获取环境信息（例如区块高度）。原来以太坊的合约中，获取环境信息的操作需要替换为通过OVM获取，所以我们需要修改原来的合约，我们新建一个Optimism编译器，将原来的智能合约编译成新的OVM字节码，在OVM环境内运行。此时智能合约在L1和L2上都在OVM内运行，因此相同的输入因该得到相同的输出。</font></p>
<h3 id="font-style-color-rgb-51-51-51-零知识卷叠（ZK-Rollup）-font"><font style="color:rgb(51, 51, 51);">零知识卷叠（ZK Rollup）</font></h3>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/45785720/1724668104363-1686f893-34e5-46b2-9d7a-fe608ef27101.png" alt></p>
<p>ZK Rollup使用零知识证明来“证明”L2提交到L1上交易的正确性。零知识证明（Zero-Knowledge Proof）指“在不泄露陈述内容的情况下证明陈述有效性的方法”。例如现在知道只有拥有Alice的私钥才能还原用Alice公钥加密的内容，那么Alice想要证明其拥有Alice的私钥，他就可以要求Bob发送一个用Alice公钥加密的随机值，如果Alice能够还原这个随机值，那么就可以证明Alice确实拥有Alice的私钥。这里Alice并没有泄露自己的私钥，而证明了自己确实拥有私钥，这就是零知识证明的一个例子。</p>
<p>ZK Rollup在以太坊主链下执行交易，定期将执行过的交易打包成批（batch），提交到以太坊上。每个提交批次会由L2的运营商在链下生成有效性证明，向以太坊主链证明状态变化的有效性，这个有效性证明即是一种零知识证明。在ZK Rollup中，卷叠（即Rollup）的状态由部署在以太坊上的智能合约维护，这个智能合约也负责验证有效性证明的正确性。一个批次的数据会被打包成以太坊主链上的一笔交易，这笔交易由多笔输入和输出，L2上交易的原始数据则以二进制的形式被打包放在交易的Calldata字段中。虽然Calldata不存储到以太坊的状态中，但是他作为以太坊的历史日志的一部分，一直存储在链上。ZK Rollup由于其良好的用户体验（资金推出不需要等待至少一周的挑战期），现在是以太坊L2扩展方案的主要发展方向。</p>
<h4 id="ZK-Rollup机制">ZK-Rollup机制</h4>
<p>ZK Rollup的详细运营机制入下：</p>
<ol>
<li>用户通过向以太坊上Rollup合约转账来进入二层网络，同时其也可以在二层网络中将资金发送到指定账户来将资金重新转移回以太坊。</li>
<li>用户在二层网络中交易，交易将被二层网络中的运营商检查核验，如果交易没有问题，则被打包入二层网络的区块中。在ZK Rollup中，负责执行交易，打包交易的人叫运营商。在某些情况下，运营商可以是一个中心化实体（即排序者），也可以是一组通过权益证明轮换的运营商角色。由于二层网络中运营商较少，那么我们该如何保障二层网络的安全性？ZK Rollup中，运营商可以通过拒绝将用户的交易添加到批次中来恶意为难用户。因此ZK Rollup允许用户在认为自己收到运营商恶意攻击时，直接向主网上的ZK Rollup智能合约提交交易。在通过权益证明轮换运营商的机制中，网络中的人需要质押二层合约中的资金来获取成为运营商的机会，每份质押的额度会影响质押者被选中的机会。如果运营商被选中后尝试实施恶意的行为，那么他的保证金将会被全部没收。</li>
<li>在有足够的交易后，二层网络的运营商将计算有效性证明（即零知识证明）提交给以太坊上的验证合约（即我们刚刚说的ZK Rollup合约）。所有二层网络中的账户会被组织成一个默克尔树，整个二层网络的装填就可以用默克尔树根来表示。这个默克尔树根的加密哈希储存在以太坊链上的智能合约中，让智能合约可以跟踪二层网络中的状态变化。根据计算零知识证明的方式有两种，分别是ZK-SNARK和ZK-STARK.</li>
<li>如果以太坊上的智能合约验证零知识证明后没问题，就需要将先前的状态（旧默克尔树根）更新到新状态（新默克尔树根）。通过验证零知识证明，我们旧不用在以太坊上再执行一次交易，从而达到扩容的目的。</li>
</ol>
<h4 id="交互式与非交互式零知识证明">交互式与非交互式零知识证明</h4>
<p>零知识证明也非为交互式与非交互式，在交互式零知识证明中，验证者需要和证明者来回互动：首先证明者需要给验证者V发送承诺，接着验证者V给证明者P发送挑战，最后证明者P再回复挑战。而再非交互式零知识证明中，证明方发送证明后，验证者只需要验证证明就可以知道证明的有效性。例如之前讲到的公钥的真实性问题——我们如何证明从网络上获取到的Bob的公钥属于Bob？我们可以通过挑战-应答确定Bob公钥的真实性，我们使用Bob公钥加密一个随机数，如果Bob可以将我们的随机数还原出来，那么我们就可以确定Bob的确持有相应的私钥——这就是交互式的零知识证明。我们还可以通过证书机制，来保证公钥的真实性，Bob可以在分发公钥的时候将证书一起分发出去，而其他人只需要验证证书的有效，就可以确定Bob公钥的真实性——这就是非交互式的零知识证明。非交互式零知识证明币交互式零知识证明更具安全性，而在ZK-Rollup中最常用到的ZK-SNARK和ZK-STARK都是非交互式的零知识证明。</p>
<h4 id="ZK-SNARK">ZK-SNARK</h4>
<p>ZK-SNARK（Zero-Knowledge Succinct Non-Interactive Argument of Knowledge）是一种零知识证明系统，具备非交互性、简洁性和高效性。</p>
<ol>
<li>系统通过将问题转化为一个布尔电路（Boolean Circuit）或算术电路（Arithmetic Circuit），使之可以被表示为一系列的逻辑门（AND、OR、NOT）或数学操作。通过这些电路，复杂的问题被转换为简单的数学问题。</li>
<li>生成系统的公共参数和秘密参数。公共参数是公开的，而秘密参数必须在生成后被销毁，否则可能导致系统被攻击。 信任设定是 ZK-SNARK 的一个主要缺点，因为它需要完全信任生成这些参数的实体。</li>
<li>证明者利用公共参数和自己的秘密信息生成一个简洁的证明，证明他知道一个满足特定电路的输入。</li>
<li>验证者使用公共参数和证明来快速验证证明的有效性，而不需要了解输入本身。</li>
</ol>
<h4 id="ZK-STARK">ZK-STARK</h4>
<p>ZK-STARK （Zero-Knowledge Scalable Transparent Argument of Knowledge）   是 ZK-SNARK 的一种改进，旨在克服 ZK-SNARK 的一些限制，如对可信设定的依赖。 ZK-STARK 不需要信任设定，所有的参数都是通过公开随机源生成的，因此更加安全和透明。 ZK-STARK 具有更好的可扩展性，可以处理更大的数据集和更加复杂的计算任务。它的证明生成和验证时间随电路大小线性增长，而 ZK-SNARK 的复杂度增长更快。ZK-STARK 使用哈希函数作为主要的加密原语，这使得它在理论上对量子计算攻击更加安全，而 ZK-SNARK 依赖于椭圆曲线密码学，对量子计算的攻击更为脆弱。</p>
<h2 id="补充-Layer-0-扩展方案Zk-bridge">补充 Layer 0 扩展方案Zk-bridge</h2>
<h3 id="ZK-Bridge机制">ZK-Bridge机制</h3>
<p><font style="color:rgb(0, 0, 0);">ZKBridge 是一种结合了零知识证明 (Zero-Knowledge Proof, ZKP) 技术的跨链桥接协议，旨在提高跨链通信的安全性和效率。它主要通过零知识证明来验证跨链交易的真实性，而不需要信任第三方。这使得不同区块链之间能够安全地互相传输数据或资产。ZKBridge内的参与者主要分为四种角色：发送链（Source Chain），发起跨链交易的链；目标链（Target Chain），接受并处理跨链交易的链；证明者（Prover），负责生成零知识证明的实体，它可以是一个智能合约或节点；验证者（Verifier），在目标链上验证零知识证明的实体，通常是一个智能合约。</font></p>
<h3 id="font-style-color-rgb-0-0-0-ZK-Bridge协议-font"><font style="color:rgb(0, 0, 0);">ZK-Bridge协议</font></h3>
<p><font style="color:rgb(0, 0, 0);">其协议沟通流程如下：</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/45785720/1724344404333-5059449b-e499-477f-a2eb-ddcac496d387.png" alt></p>
<ol>
<li><font style="color:rgb(0, 0, 0);">用户在发送链上发起跨链交易，例如将资产从链 A 转移到链 B。这一步骤会触发链 A 上的智能合约记录该事件。</font></li>
<li><font style="color:rgb(0, 0, 0);">证明者监控链 A 上的事件，并根据该事件生成相应的零知识证明。这个证明包含了链 A 上交易发生的事实，但不会泄露交易的具体内容。</font></li>
<li><font style="color:rgb(0, 0, 0);">证明者将生成的零知识证明提交到链 B。链 B 上的智能合约会接收到该证明，并准备进行验证。</font></li>
<li><font style="color:rgb(0, 0, 0);">链 B 上的验证者（通常是智能合约）使用零知识证明验证算法来验证提交的证明是否有效。如果证明通过验证，链 B 将执行相应的操作，例如释放在链 B 上的代币或调用合约函数。</font></li>
<li><font style="color:rgb(0, 0, 0);">验证成功后，链 B 执行相应的逻辑，跨链交易完成。例如，用户在链 A 上锁定的资产会在链 B 上释放给用户。</font></li>
</ol>
<h3 id="font-style-color-rgb-0-0-0-ZK-Bridge-font-优点"><font style="color:rgb(0, 0, 0);">ZK-Bridge</font>优点</h3>
<p><font style="color:rgb(0, 0, 0);">ZKBridge 的优点有：</font></p>
<ul>
<li><strong><font style="color:rgb(0, 0, 0);">安全性高</font></strong><font style="color:rgb(0, 0, 0);">: 由于零知识证明的不可伪造性，ZKBridge 极大地提高了跨链交易的安全性，避免了中间人攻击和双花问题。</font></li>
<li><strong><font style="color:rgb(0, 0, 0);">隐私性强</font></strong><font style="color:rgb(0, 0, 0);">: 零知识证明允许证明者不泄露任何具体信息，从而增强了交易的隐私性。</font></li>
<li><strong><font style="color:rgb(0, 0, 0);">效率高</font></strong><font style="color:rgb(0, 0, 0);">: ZKBridge 减少了跨链交易所需的验证步骤，因为验证者只需验证零知识证明，而不必重放整个交易过程。</font></li>
</ul>
</div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">nty</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Nie-Tianyi"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/%E4%BB%80%E4%B9%88%E6%98%AFHadoop_preprocessed/" title="Hadoop">Hadoop</a><time datetime="2025-09-14T12:46:25.000Z" title="发表于 2025-09-14 20:46:25">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/12/Raft%E5%8D%8F%E8%AE%AE_preprocessed/" title="Raft协议">Raft协议</a><time datetime="2025-09-12T12:46:25.000Z" title="发表于 2025-09-12 20:46:25">2025-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/07/%E5%87%B8%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96%E4%B8%80_preprocessed/" title="凸函数优化笔记（1）">凸函数优化笔记（1）</a><time datetime="2025-09-07T12:46:25.000Z" title="发表于 2025-09-07 20:46:25">2025-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/27/%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89_preprocessed/" title="线性函数定义">线性函数定义</a><time datetime="2025-08-27T12:46:25.000Z" title="发表于 2025-08-27 20:46:25">2025-08-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A2%AF%E5%BA%A6%E6%8E%A8%E5%AF%BC_preprocessed/" title="神经网络's Gradient">神经网络's Gradient</a><time datetime="2025-08-16T12:46:25.000Z" title="发表于 2025-08-16 20:46:25">2025-08-16</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Hadoop/" style="font-size: 1.1em; color: #999">Hadoop</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" style="font-size: 1.1em; color: #999">编程基础</a> <a href="/tags/%E5%87%B8%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96/" style="font-size: 1.1em; color: #999">凸函数优化</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" style="font-size: 1.1em; color: #999">线性回归</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 1.3em; color: #99a1ac">分布式系统</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 1.1em; color: #999">线程池</a> <a href="/tags/PyO3/" style="font-size: 1.1em; color: #999">PyO3</a> <a href="/tags/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/" style="font-size: 1.1em; color: #999">加密货币</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/" style="font-size: 1.1em; color: #999">逻辑回归</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 1.1em; color: #999">人工智能</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.1em; color: #999">数学</a> <a href="/tags/Python%E8%AF%AD%E6%B3%95/" style="font-size: 1.1em; color: #999">Python语法</a> <a href="/tags/numba/" style="font-size: 1.1em; color: #999">numba</a> <a href="/tags/Rust/" style="font-size: 1.4em; color: #99a5b6">Rust</a> <a href="/tags/Raft/" style="font-size: 1.1em; color: #999">Raft</a> <a href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" style="font-size: 1.1em; color: #999">异步编程</a> <a href="/tags/Python/" style="font-size: 1.3em; color: #99a1ac">Python</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/" style="font-size: 1.1em; color: #999">数据科学</a> <a href="/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/" style="font-size: 1.4em; color: #99a5b6">梯度下降</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.1em; color: #999">数据库</a> <a href="/tags/Axum/" style="font-size: 1.1em; color: #999">Axum</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 1.1em; color: #999">共识算法</a> <a href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" style="font-size: 1.1em; color: #999">智能合约</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 1.1em; color: #999">并发编程</a> <a href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" style="font-size: 1.1em; color: #999">神经网络</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0/" style="font-size: 1.1em; color: #999">线性函数</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 1.1em; color: #999">性能优化</a> <a href="/tags/PostgreSQL/" style="font-size: 1.1em; color: #999">PostgreSQL</a> <a href="/tags/%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/" style="font-size: 1.1em; color: #999">共识协议</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 1.5em; color: #99a9bf">机器学习</a> <a href="/tags/Tokio/" style="font-size: 1.1em; color: #999">Tokio</a> <a href="/tags/%E6%AF%94%E7%89%B9%E5%B8%81/" style="font-size: 1.1em; color: #999">比特币</a> <a href="/tags/%E4%BA%8C%E5%B1%82%E6%89%A9%E5%B1%95/" style="font-size: 1.1em; color: #999">二层扩展</a> <a href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" style="font-size: 1.2em; color: #999da3">以太坊</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 1.1em; color: #999">大数据</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 1.4em; color: #99a5b6">区块链</a> <a href="/tags/SQL/" style="font-size: 1.1em; color: #999">SQL</a> <a href="/tags/Web%E6%A1%86%E6%9E%B6/" style="font-size: 1.1em; color: #999">Web框架</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      <a class="card-more-btn" href="/archives/"
            title="查看更多">
            <i class="fas fa-angle-right"></i>
          </a>
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/09/">
            <span class="card-archive-list-date">
              九月 2025
            </span>
            <span class="card-archive-list-count">3</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/08/">
            <span class="card-archive-list-date">
              八月 2025
            </span>
            <span class="card-archive-list-count">3</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/07/">
            <span class="card-archive-list-date">
              七月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/06/">
            <span class="card-archive-list-date">
              六月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/05/">
            <span class="card-archive-list-date">
              五月 2025
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/03/">
            <span class="card-archive-list-date">
              三月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/10/">
            <span class="card-archive-list-date">
              十月 2024
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/09/">
            <span class="card-archive-list-date">
              九月 2024
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">19</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-09-16T18:17:56.195Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By nty</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>