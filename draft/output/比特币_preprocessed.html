<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>nty的技术博客 | nty的技术博客</title><meta name="author" content="nty"><meta name="copyright" content="nty"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="密码学基础 现代密码学中，我们通常要求一个加密的系统满足一下几点要求（CIA）：  Confidentiality，保密性，及信息不能泄露给不应该知道这个信息的人。 Integrity，完整性，及数据在传输的过程中不能被篡改，如果被篡改，通信双方应该立马能发现。 Accessiblity，可通达性，及系统应该免于DDos等攻击，通信双方可以保持通信畅通。 （也有说Authority的，权威性，及保">
<meta property="og:type" content="website">
<meta property="og:title" content="nty的技术博客">
<meta property="og:url" content="https://nie-tianyi.github.io/draft/output/%E6%AF%94%E7%89%B9%E5%B8%81_preprocessed.html">
<meta property="og:site_name" content="nty的技术博客">
<meta property="og:description" content="密码学基础 现代密码学中，我们通常要求一个加密的系统满足一下几点要求（CIA）：  Confidentiality，保密性，及信息不能泄露给不应该知道这个信息的人。 Integrity，完整性，及数据在传输的过程中不能被篡改，如果被篡改，通信双方应该立马能发现。 Accessiblity，可通达性，及系统应该免于DDos等攻击，通信双方可以保持通信畅通。 （也有说Authority的，权威性，及保">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nie-tianyi.github.io/images/avatar.png">
<meta property="article:published_time" content="2025-09-16T17:31:22.756Z">
<meta property="article:modified_time" content="2025-09-16T17:30:18.680Z">
<meta property="article:author" content="nty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nie-tianyi.github.io/images/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nie-tianyi.github.io/draft/output/%E6%AF%94%E7%89%B9%E5%B8%81_preprocessed.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'nty的技术博客',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'page'
}</script><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div class="page" id="body-wrap"><header class="not-home-page" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">nty的技术博客</span></a></span><div id="menus"></div></nav><div id="page-site-info"><h1 id="site-title"></h1></div></header><main class="layout" id="content-inner"><div id="page"><div class="container" id="article-container"><h2 id="密码学基础">密码学基础</h2>
<p>现代密码学中，我们通常要求一个加密的系统满足一下几点要求（CIA）：</p>
<ol>
<li>Confidentiality，保密性，及信息不能泄露给不应该知道这个信息的人。</li>
<li>Integrity，完整性，及数据在传输的过程中不能被篡改，如果被篡改，通信双方应该立马能发现。</li>
<li>Accessiblity，可通达性，及系统应该免于DDos等攻击，通信双方可以保持通信畅通。 （也有说Authority的，权威性，及保证信息来源真实可信）</li>
</ol>
<p>现代密码学和密码加密技术通常被分为两类：对称加密和非对称加密。对称加密是指用于加密和解密的密钥是一样的，对称加密中加密和解密通常是“对称”的操作。非对称加密中，加密和解密的密钥是不一样的。非对称加密中，存在一对密钥，其中一个用于加密，另一个用于解密。用其中一个密钥加密的信息，只能用另一个密钥解密，而反过来用另一个密钥加密的信息，也只能由当前密钥解密。</p>
<p>对称加密中又通常分为流加密（stream cipher）和块加密（block cipher），常见的流加密算法有chacha20。chacha20 中，通过一段固定的伪随机 2 进制流生成算法，用密钥作为伪随机生成器的种子，生成一段由01组成的２进制比特流。加密者将要加密的明文跟刚生成的 2 进制比特流做 XOR 操作，就能得到加密后的密文。而解密者只需要拿到密钥，用相同的伪随机２进制生成算法和密钥（也是伪随机生成算法的种子），就能生成相同的比特流。解密者此时只需将比特流跟密文做 XOR 操作，就能得到加密前的明文。</p>
<p>XOR（通常表示为<font style="color:rgb(51, 51, 51);">⊕</font>）操作具有对称性，例如我们的明文是010010，我们的生成的比特流是011010，那么加密后，我们能得到001000。而解密时，我们只需要将密文同相同的比特流做XOR操作，就能恢复明文，即 001000 <font style="color:rgb(51, 51, 51);">⊕</font> 011010 = 010010。</p>
<p>常见的块加密算法有 DES 和 AES 算法，以 DES 算法举例，需要加密的明文被分为多个一定长度的小块（DES中，是64 bit，如果长度不足，用０填充），每一块经过16轮的一定规则的替换和重新排列，被加密成密文，而置换和重新排列的规则，是由密钥决定的。解密时，解密者通过密钥得到相同的替换和重新排列规则，解密者通过这些相同的规则，能将密文还原成明文。</p>
<p>非对称加密中，常见的算法有RSA加密算法和ECC椭圆圆锥曲线加密算法。非对称加密比起对称加密，不仅可以用于数据加加密，还可以用于数字签名，用于保证数据的完整性和权威性。非对称加密，也是区块链中，最常用的加密方式。</p>
<h3 id="RSA加密">RSA加密</h3>
<p>RSA算法的数学理论支持来源于欧拉定理，欧拉定理描述如下：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/490dd768795e3beb9c1d92bb192733c1.svg" alt="image"></p>
<p>其中:</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/ed518a2d315c5e1132071dcc62b915f9.svg" alt="image"></p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/42b5b118fef993dd42ef250b2df2bd53.svg" alt="image"></p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/308e9dced958b8ae9b9df59628a6d19b.svg" alt="image"></p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/350df3aef01c935544a7463d25985d6e.svg" alt="image"></p>
<p>根据这个定理，我们可以得出RSA算法，RSA密钥生成算法具体步骤如下：</p>
<ol>
<li>选取两个较大的质数p和q</li>
<li>计算p和q的乘积，n = pq</li>
<li>计算 φ(n)<font style="color:rgb(5, 5, 5);"> = (p-1)(q-1)</font></li>
<li>随机选取一个正整数 e (与 <font style="color:rgb(5, 5, 5);">φ(n) 互质且大于1，小于φ(n)</font>)，计算d，使得:ed ≡ 1 (mod φ(n))</li>
<li>选取 ( e , n ) 作为公钥， ( d , n ) 作为私钥</li>
</ol>
<p>用公钥加密的信息只能用私钥解密，而反过来私钥加密的信息只能通过公钥解密。密钥的生成者通常会将公钥公开，而将私钥秘密保存。当互联网上有人想要给密钥的生成者发送加密信息时，通常会先找密钥的生成者拿取其公钥，然后发送者会用公钥加密加密想要发送的信息 M，此时生成的密文 C 只能用私钥还原。这样就避免的信息M被互联网上其他的人知道。</p>
<p>如果有攻击者想要通过公钥（ e , n ）计算出私钥，那么他首先要计算出φ(n)。 而想要计算出φ(n)，攻击者只能通过暴力破解穷举 n 所有的质数因数。实践中 n 通常是一个十分巨大的数字（例如现在HTTPS证书上常见的公钥 n为一个2048位的二进制数字），暴力破解需要耗费攻击者大量时间和算力。因此密钥拥有者只需要定期更换密钥，就能保证其信息的安全。</p>
<p>当需要得到密文 C 时，加密者只需要计算明文 M 的 e 次方模 n：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/86f7c3d43aff2f5e846015a34dc3e6f6.svg" alt="image"></p>
<p>而当解密者需要还原被加密的信息 M 时，他只需要计算 C 的 d 次方模 n：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/389c157ca8bca6e8158a7ccb0159f943.svg" alt="image"></p>
<p>其原理为：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/49b4661262ecc1e0173e5969743f64c5.svg" alt="image"></p>
<p>其中：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/42bd9637a47f8031e0b0a7a2d367540f.svg" alt="image"></p>
<h3 id="ECC椭圆曲线加密">ECC椭圆曲线加密</h3>
<p>ECC 椭圆曲线加密也是非对称加密的一种方式，也是比特币中用的最多的加密方式。椭圆曲线在相同密钥长度的情况下，能做到比RSA更高的安全等级。</p>
<p>椭圆曲线 E 在数学上通常表示为：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/4a8d6d4f7f80bf675ee5c903378c4524.svg" alt="image"></p>
<p>其常见的例子以及函数图像有：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1719307208039-2956adf5-773a-4116-ab64-c415f1093ce5.png" alt></p>
<p>而在密码学中，常用的椭圆曲线表达式一般限定为（即二次项系数为 0）：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/52d0f0102e4f360fa967a2fea558ce8a.svg" alt="image"></p>
<p>在这样的椭圆曲线上，我们定义一套特殊的运算规则。我们定义在椭圆曲线上,有P和Q两点，其 P + Q 的结果表示为PQ直线与椭圆曲线相交的第三个点 R’ 的关于x轴的对称点R。其几何表示为：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1719307745134-3a6cd305-bff9-49fc-80f1-6738d30f7516.png" alt></p>
<p>我们还定义，一个点的关于x轴的对称点为其负数，即 R’= - R。</p>
<p>如果P和Q是曲线上重合的两点，那么我们则计算椭圆曲线上p点的切线与曲线其他部位的交点 R’，然后计算R’关于x轴的对称点R。 我们记作 P + Q = P + P = 2P = R。如果计算3P，则是先计算 2P，然后计算2P + P = 3P。这样定于出来的加法和乘法符合交换律和结合律，即 P+Q = Q+P，(ab)P = a(bP)。在数学上，我们称具有这种性质的集合及其运算规则为阿贝尔群。</p>
<p>连续的椭圆曲线比较容易被找到规律，并不适合用于加密。为了实现离散的结果，我们取椭圆曲线内一些离散的点作为集合。为此，我们把椭圆曲线定义在离散的域{0，1，2，…，p-1}内，其中p为一个较大的质数，其通常表达为：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/3cd31cfceb3cd970a0629d263eab48cb.svg" alt="image"></p>
<p>并将其操作定义如下：</p>
<ul>
<li>其加法规则如下：</li>
</ul>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/ecb286bdf15b4f38b4dec0e70ecdce59.svg" alt="image"></p>
<p>例如：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/bb5936b5fbfb5941830133632373fca6.svg" alt="image"></p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/3b4acc96c0ad920f80b7107d9b0a07c2.svg" alt="image"></p>
<p>补充：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/e02e7d44a3dd6d7e7a0d0685c322db9b.svg" alt="image"></p>
<ul>
<li>其取反规则如下:</li>
</ul>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/7fc5da7165b1d14bc468c0e683b992dd.svg" alt="image"></p>
<p>例如：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/bb5936b5fbfb5941830133632373fca6.svg" alt="image"></p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/02517e0c3050774d9d7024af6e5d9ee5.svg" alt="image"></p>
<ul>
<li>其乘法规则如下:</li>
</ul>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/076569446ea1894d6ee3a67ca3d5ac92.svg" alt="image"></p>
<p>例如：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/bb5936b5fbfb5941830133632373fca6.svg" alt="image"></p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1916c91009b1f6b3697fbcdc56f9fa47.svg" alt="image"></p>
<ul>
<li>其除法规则如下：</li>
</ul>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/cc26f97bc443505245993dd7448ea23e.svg" alt="image"></p>
<p>下图是上述计算的计算结果的图形表示，这样定义出的集合与运算规则也符合阿贝尔群，而且比起连续的椭圆函数，更不可预测。</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1719367615331-a9bea303-f1a8-4db8-9991-03b813729e3f.png" alt></p>
<p>在这样定义出来的阿贝尔群有个特殊的性质，群内有点存在最小正整数n，使得nP = P，即一个点的n倍等于其自己。例如上图中的 27P = （3，13）=-P，28P = （3，10） = P，这样我们则称 28 为P的“阶”。我们也把P ~ 28P这些点叫做循环阿贝尔群，同时也写作：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/3573aa9b40945794fc4ba19dfe531fe3.svg" alt="image"></p>
<p>如果定义域内的点不存在一个n，能使得<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/d4a3709cc0c8f57307412fcb52af9a5f.svg" alt="image">，则我们称P是无限阶的。</p>
<p>椭圆曲线加密算法所有使用的就是循环阿贝尔群。在椭圆曲线加密算法中，我们选取一个有阶的点G，即<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/40f6bf31a490eccaad1bbcba0e3bc118.svg" alt="image">；我们在选取一个小于n的数字k，并且计算出<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/7b0a9ae18276dbd84ab2a3ef819cc1f2.svg" alt="image">。这样的计算满足one-way trap-door函数的性质：</p>
<ul>
<li>根据加法法则，如果我们拥有k和G，则计算出K相对简单。</li>
<li>但是如果我们只知道G和K，而求解出k则困难很多</li>
</ul>
<p>这里我们称G点为基点（base point），k为私钥（private key），而K为公钥（public key）。</p>
<p>ECC椭圆曲线加密算法具体如下：</p>
<ol>
<li>Alice选取一条指定椭圆曲线E，以及椭圆曲线上一点G，使其满足<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/40f6bf31a490eccaad1bbcba0e3bc118.svg" alt="image"></li>
<li>Alice随机选择一个私钥k（k&lt;n）,并根据私钥生成公钥 <img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/f11b573886ed054bd38614427befac00.svg" alt="image"></li>
<li>Bob想要同Alice通信，他请求Alice的公钥（椭圆曲线E，公钥K，基点G）</li>
<li>Bob将想要发送的信息编码到椭圆曲线上的一点M，并生成随机数r (r&lt;n)</li>
<li>Bob计算密文<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/6c0e94ddba8ef3547d7f7ee8c2e7fd1d.svg" alt="image">， <img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/adf85811959f5983db3e7f30a1d97c1b.svg" alt="image">， 并且将C1，C2传输给Alice</li>
<li>Alice只需计算 <img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/49b32ce20b6070f7e36c3ef032913997.svg" alt="image">，就能得到加密前的明文 M</li>
</ol>
<p>Alice能还原出M的原理如下：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/bf7d134ee933c299986ccf115cd9bbae.svg" alt="image"></p>
<p>其中：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/a2c350eb05174ea1f9c349626427c77f.svg" alt="image"></p>
<p>比特币使用secp256k1作为其圆锥曲线加密的方案，在这个具体实现中，其选取的椭圆曲线为：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/e065615f7ec9239d11cca3b4824f9ae4.svg" alt="image"></p>
<p>其选择了一个很大数质数作为p，其值为：</p>
<p>0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F  即：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/91a0af8d0bc273bb8ddccc60bb6ab524.svg" alt="image"></p>
<p>在secp256k1中，其基点G定义如下：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/31d2d4b401ee493a4204fc992146cacd.svg" alt="image"></p>
<p>其中：<br>
Gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</p>
<p>Gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8</p>
<p>而G的阶n为：<br>
n=0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</p>
<h3 id="签名原理">签名原理</h3>
<p>数字签名也被广泛用于比特币系统中。数字签名不仅可以保证数据的权威性，确保数据的来源可信，还能保证数据的完整性，防止签名的数据被篡改。在非对称加密中，我们使用公钥加密的信息，只能被私钥解密。而在签名算法中，我们使用私钥加密文件的哈希值，这样，只有拥有私钥的人可以签名文件，而任何人都可以同过使用公钥解密签名，以此验证签名的有效性。</p>
<p>在RSA非对称加密算法中，我们通过算法生成了一对公钥<code>（e，n）</code>和私钥<code>（d，n）</code>，使用一个钥匙加密的信息，只能用另一个钥匙解密。而RSA签名算法中，我们使用私钥加密需要签名文件的哈希值。任何想要验证签名的人，都可以使用公钥解密签名，验证者只需比对解密后的信息与文件哈希值，就能验证签名的有效性。</p>
<p>签名者生成文件签名的流程如下：</p>
<ol>
<li>签名者通过RSA算法生成一对用于签名的公钥<code>（e，n）</code>和私钥<code>（d，n）</code></li>
<li>签名者计算需要签名文件的哈希值 <img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/6d12af7bcbd1b12f99fc95cb4df50adf.svg" alt="image"></li>
<li>签名者生成签名 S：</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/10b340ce9ad7c3379540123fca664ee3.svg" alt="image"></p>
<ol start="4">
<li>当有人需要使用文件时，签名者需将文件本身 File，文件签名S，以及验证签名的公钥<code>（e，n）</code>一并传送给使用人。</li>
</ol>
<p>当任何人想要验证签名时，他需要计算：</p>
<ol>
<li>计算文件的哈希值 <img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/e934a7100168d126cc123aa18e2ebb6d.svg" alt="image"></li>
<li>使用签名者的公钥解密签名，得到H2</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/cb06cec17254ece27ef2047f03eceb08.svg" alt="image"></p>
<ol start="3">
<li>验证者通过比较<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/5211bedb600e31046860da77076ec475.svg" alt="image">和<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/b0f96b1b8b1e25124bcfe3f319d434c5.svg" alt="image">，就能知道该签名的有效性：如果H1同H2一样，那么签名是有效的；如果<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/5211bedb600e31046860da77076ec475.svg" alt="image">同<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/b0f96b1b8b1e25124bcfe3f319d434c5.svg" alt="image">不一样，那么签名无效。</li>
</ol>
<p>其具体流程，可以概括为下图：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1719381650190-87b36aeb-da78-412c-8b95-f1a727b2f933.png" alt></p>
<p>在签名过程中，使用哈希函数对需要签名的文件生成摘要是非常有必要。如果直接对原文件签名，将会引起诸多问题：第一个是如果文件过大，那么加密和解密的过程将浪费大量计算资源；第二个是攻击者可以使用存在性伪造攻击（Existential Forgery Attack）来迷惑验证者，让验证者误以为攻击者拥有私钥。攻击者虽然无法指定信息的内容，但是仍可以生成有效签名。存在性伪造攻击过程如下：</p>
<ol>
<li>攻击者可以随机生成一条假签名 S’，并计算其对应的假消息M’：</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/4e1c27cc697c75a1b2bef398fc7c7d4a.svg" alt="image"></p>
<ol start="2">
<li>攻击者可以通过暴力破解，穷举S’，使其找到一条M’与其对应，并且M’具有实际意义</li>
</ol>
<p>椭圆曲线同样可以用于签名算法，并且使用椭圆曲线的椭圆曲线签名算法（Elliptic Curve Digital Signature Algorithm，ECDSA）比RSA签名算法更高效，更安全。生成椭圆曲线签名的步骤如下：</p>
<ol>
<li>通过椭圆曲线加密算法生成一对公钥（公钥K ，基点G，椭圆函数E）和私钥k</li>
<li>求需要签名的消息M的哈希值 <img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/45747e777e12094cd4587b3d7fac48e7.svg" alt="image"></li>
<li>选择一个随机的整数 d（大于零，小于n）</li>
<li>计算点<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/3ef40783557141da91d1094a8c3a990b.svg" alt="image">，其中</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1ac3983d8eb49f627634e7c1bf38f4b3.svg" alt="image"></p>
<ol start="5">
<li>计算r，如果r=0，则重新选则d并重新计算</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1be80d1d522568851ef2040fa4dfd7f1.svg" alt="image"></p>
<ol start="6">
<li>计算s，如果s=0，则重新选择d并重新计算</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/95aa16a03f7519848d8b50b2f1e0ec9b.svg" alt="image"></p>
<ol start="7">
<li>将消息M，签名<code>（r，s）</code>以及公钥<code>（K，G，E）</code>一并发送给验证者。</li>
</ol>
<p>而验证签名，只需要计算：</p>
<ol>
<li>消息的哈希值<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/45747e777e12094cd4587b3d7fac48e7.svg" alt="image"></li>
<li>计算 w：</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/bc8dffc5a6a086710363dad0d6b418fe.svg" alt="image"></p>
<ol start="3">
<li>计算u1和u2：</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/3ac7e9966bcc749d7ecacb946beb42b8.svg" alt="image"></p>
<ol start="4">
<li>计算点R：</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/facc7fb2e8f4302d0176e4a00c7f73ce.svg" alt="image"></p>
<ol start="5">
<li>计算v:</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/30648b14fd80436324601c74b2f471cb.svg" alt="image"></p>
<ol start="6">
<li>比较v和r，如果v和r一样，则签名有效；如果不一样，则签名无效</li>
</ol>
<h3 id="比特币的账户设计">比特币的账户设计</h3>
<p>比特币中，账户通常就指的是一对公钥和私钥。这对公钥和私钥，既可以用来签名，也可以用来加密。比特币中，我们用公钥标识一个钱包。在不同的转账模式之下，我们用不同的算法对公钥进行一些运算，并将运算结果叫做钱包的地址（一个钱包可以有多个地址，一个转账模式对应一个地址），例如在P2PKH（Pay-to-Public-Key-Hash）转账模式之下，我们把公钥的哈希值作为钱包的地址；在P2PK（Pay-to-Public-Key）转账模式之下，我们直接使用公钥作为地址。以下是在P2PKH转账模式之下，地址的具体生成流程：</p>
<ol>
<li>对公钥进行SHA256哈希运算， 再进行RIPEMD-160哈希，得到公钥哈希值</li>
<li>在公钥哈希前添加一个字节的版本前缀，例如（0x00表示比特币主网），得到地址</li>
<li>再对公钥哈希进行两次SHA256哈希运算，其前四个字节作为校验和，添加到地址结尾</li>
<li>对地址进行Base58Check编码，等到最终地址</li>
</ol>
<h2 id="交易">交易</h2>
<p>比特币作为一种电子货币，本质上是一个公共的去中心化的分布式账本。在这个网络中，每个人都拥有一个账本。当交易发生时，交易双方向网络中广播自己交易。所有收到广播的人，都会将交易记录在自己的账本上。比特币运用密码学和各种算法，确保了分布式账本内容的公平和一致。与一般记账账本不同的是，比特币账本，并不直接记录每个参与者的余额，而是记录网络中发生的每一笔交易，例如“Alice给Bob转账了300元”。当有参与者想要知道自己账户余额时，他需要找当账本内每一本与自己有关的交易，然后挨个计算，最后才能得到自己账户的余额。账本本身是一个由首尾相连的区块所组成的区块链。每个区块，都相当于账本内的一页账目，记录了比特币网络中发生的每一笔合法的交易。而交易，则像是每页账目中的条目，具体记录了每一笔钱从谁转账给了谁。</p>
<h3 id="交易结构和UTXO">交易结构和UTXO</h3>
<p>在比特币中，每一个交易被具体分为了交易的输入<code>CTxIn</code>和交易的输出<code>CTxOut</code>，即类似 “Alice（交易的输入） 给 Bob（交易的输出） 转账了 300元”的格式。其中<code>CTxIn</code>包含了转账人的地址和转账数额（例如上例中的300元），<code>CTxOut</code>包含了收账人的地址以及收账数额（例如300元）。在这里，转账的数额与收账的数额不一定相等，例如：Alice可能转账了300元，而Bob只收帐了290元——这其中10元的差额，会被作为转账的手续费，交给矿工，即记账者（这部分后面会讲到）。当然，转账的数额不可能比收账的数额小，这样的交易是不会被矿工承认的。</p>
<p>以下是比特币源码中，关于交易部分的代码：（以下所有代码所使用的比特币项目的源码链接：<a target="_blank" rel="noopener" href="https://github.com/bitcoin/bitcoin.git">https://github.com/bitcoin/bitcoin.git</a>，Accessed On: 2024/6/27）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The basic transaction that is broadcasted on the network and contained in</span></span><br><span class="line"><span class="comment"> * blocks.  A transaction can contain multiple inputs and outputs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTransaction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Default transaction version.</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> CURRENT_VERSION&#123;<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The local variables are made const to prevent unintended modification</span></span><br><span class="line">    <span class="comment">// without updating the cached hash value. However, CTransaction is not</span></span><br><span class="line">    <span class="comment">// actually immutable; deserialization and assignment are implemented,</span></span><br><span class="line">    <span class="comment">// and bypass the constness. This is safe, as they update the entire</span></span><br><span class="line">    <span class="comment">// structure, including the hash.</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;CTxIn&gt; vin;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;CTxOut&gt; vout;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> version;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> nLockTime;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以看出，每笔交易中包含了多个交易的输入<code>vector&lt;CTxIn&gt; vin</code>，多个交易的输出 <code>std::vector&lt;CTxOut&gt; vout</code>，交易版本信息 <code>version</code>，以及一个用于额外添加限制条件的时间戳 <code>nLockTime</code>。交易版本信息是用去区分不同版本的交易规则的，比特币网络中的协议并非一成不变，而是随着时间演变的。当然网络内协议的改变有可能导致更新前后不兼容，从而导致链分叉、社区分裂等问题（这部分问题会在后面讲到），所以比特币社区对与协议的更改是比较保守的。<code>nLockTime</code>是用于控制交易被加入到区块中的时间的，例如交易双方想延迟交易，就可以设置这个字段，使交易只有在一定事件后才被打包入账本。当nLockTime为零时，代表交易者希望当前交易被尽快打包入区块内。而当其是一个小于500 000 000的值时，这个字段意味着这个交易在整个区块链达到这个长度前，都不希望被打包入区块；当这个字段高于500 000 000时，这个字段则被解释为Unix时间戳（自1970年1月1日后流逝的秒数），意味着在当前时间早于这个时间前，交易双方都不希望这笔交易被打包入区块。交易结构体中多个交易输入输出意味着可以出现以下情形：Alice转入了200元，Bob转也转入了200元，支付给Charly 300 元，同时也支付给Daren 95元，以及其中的差额 5元。其中的差额5元会被自动奖励给打包这笔交易的人。</p>
<p>比特币使用未花费交易输出模型（Unspent Transaction Output, UTXO）作为其交易模型。在这个模型中，用户想要使用比特币，只能以UTXO作为单位。UTXO，未花费交易输出，对应着区块链中每一笔交易中的每一个输出。例如上例中支付给Charly的300元和支付给Daren的95元，都是一个UTXO。我们把支付给Charly的300元，叫做属于Charly的一个UTXO，其面值为300元；支付给Daren的95元，属于Daren的一个UTXO，其面值为95元。当Charly想要花费这个属于他的UTXO时，他需要将整个UTXO作为交易的输入，即一次性将者300元转出去。这样的设计虽然没有直接转账一定数额的灵活和精确，但是可以保证每笔钱来源都可以被追踪。当然，这种交易模式也不一定要求Charly只能一次性使用300元，当交易所需的金额小于300元时，Charly可以创建一笔这样的的交易：Charly转入300元，转给Bob 200元，转给Charly自己95元（同样，多余的5元会被当做手续费转给矿工）。这样，Charly可以通过创建交易拆分或者聚合UTXO，将一个面值大的UTXO拆分成几个面值更小的，或者将几个面值更小的UTXO聚合成一个面值更大的UTXO。</p>
<p>需要注意的是，只有被打包好上链的交易的输出，到才能被称作是UTXO。这意味着，还没有被打包上链的交易中的输出，是不能被立马使用的。而在实践中，即便是以及被打包好的交易，也是可能被推翻的（链有可能会分叉，被消灭的分链上的交易会被要求重新打包）。因此，在实践中为了确保交易的安全（即当前交易一定生效），社区要求UTXO的拥有者只有在打包当前交易的区块后面，又有人逐个添加了6个区块后，才能花费其中的输出。</p>
<p>以下是比特币具体实现中，每一个输出<code>CTxOut</code>的具体的内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** An output of a transaction.  It contains the public key that the next input</span></span><br><span class="line"><span class="comment"> * must be able to sign with to claim it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTxOut</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CAmount nValue;</span><br><span class="line">    CScript scriptPubKey;</span><br><span class="line">    <span class="comment">// ... 下面的代码包含了这个类构造方法，重载的比较符`==`和`!=`，序列化的方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在比特币的具体实现中，每一个输出包括了一个转账金额<code>CAmount nValue</code>以及一个脚本<code>CScript scriptPubKey</code>。其中<code>CAmount</code>是一个有符号的64位整数，有符号意味着其可以为负数。但比特币网络中的转账金额是不能为负数的。这里的负数是为了比特币客户端内计算方便所设计的。同时，转账金额的单位为”聪“（satoshis）。这里是人为规定的，100 000 000聪为一个比特币。计算机中的小数是不精确的，如果直接用“0.001 比特币”这样的计数方式表示网络中的比特币，会导致出现精度不够，从而引发错误。 这样用更小单位分割每一个比特币的方法方便我们对网络内的比特币进行细小精确的分割。以下是关于<code>CAmount</code>具体的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Amount in satoshis (Can be negative) */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int64_t</span> CAmount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The amount of satoshis in one BTC. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> CAmount COIN = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** No amount larger than this (in satoshi) is valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this constant is *not* the total money supply, which in Bitcoin</span></span><br><span class="line"><span class="comment"> * currently happens to be less than 21,000,000 BTC for various reasons, but</span></span><br><span class="line"><span class="comment"> * rather a sanity check. As this sanity check is used by consensus-critical</span></span><br><span class="line"><span class="comment"> * validation code, the exact value of the MAX_MONEY constant is consensus</span></span><br><span class="line"><span class="comment"> * critical; in unusual circumstances like a(nother) overflow bug that allowed</span></span><br><span class="line"><span class="comment"> * for the creation of coins out of thin air modification could lead to a fork.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> CAmount MAX_MONEY = <span class="number">21000000</span> * COIN;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">MoneyRange</span><span class="params">(<span class="type">const</span> CAmount&amp; nValue)</span> </span>&#123; <span class="keyword">return</span> (nValue &gt;= <span class="number">0</span> &amp;&amp; nValue &lt;= MAX_MONEY); &#125;</span><br></pre></td></tr></table></figure>
<p>在比特币网络的输出中，为了确保转账交易的匿名性，我们并不直接注明收款人的姓名或者是地址。比起直接注明交易人的姓名地址，我们给每个输出加上一个锁，任何想要花费这输出的人，需要提供这个锁相应的钥匙才能花费这个UTXO。这里的锁，就是<code>CTxOut</code>中的<code>CScript scriptPubKey</code>。我们称这里的<code>scriptPubKey</code>为加密脚本（locking script）。而想要花费这个UTXO的人，需要提供相应的解锁脚本（unlocking script）。在密码学中，我们称类似的操作为Challenge-Response，即挑战和回应。这类操作通常包括一个人发起挑战，这个挑战一般只有特定的人能应答。然后一个人通过正确地给出答案，证明自己的身份。例如Bob提出问题，”Alice早上吃了什么“这类只有Alice能回答的问题。如果对面的人能正确回答问题，那么就能证明其Alice的身份。在计算机中，我们能够通过现代密码学中的非对称加密做到类似操作，例如Bob想要确定以自己通话的人的身份，那么它可以发起一个Challenge-Response：Bob用Alice的公钥加密一个随机数字，如果对面能还原这个随机数字，那么我们就能确定其Alice的身份（假设Alice的私钥只有她自己知道）。</p>
<p>在比特币的具体实现中，每一个交易的输入<code>CTxIn</code>都包含了一个指针<code>COutPoint prevout</code>，指向之前一笔交易其中的一个输出，验证脚本<code>CScript scriptSig</code>（即解锁脚本，unlocking script），用于限制交易的<code>uint32_t nSequence</code>，以及用于隔离见证的脚本<code>CScriptWitness scriptWitness</code>。以下是<code>CTxIn</code>的源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** An input of a transaction.  It contains the location of the previous</span></span><br><span class="line"><span class="comment"> * transaction&#x27;s output that it claims and a signature that matches the</span></span><br><span class="line"><span class="comment"> * output&#x27;s public key.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTxIn</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    COutPoint prevout;</span><br><span class="line">    CScript scriptSig;</span><br><span class="line">    <span class="type">uint32_t</span> nSequence;</span><br><span class="line">    CScriptWitness scriptWitness; <span class="comment">//!&lt; Only serialized through CTransaction</span></span><br><span class="line">    <span class="comment">// ... 下面的代码包含了这个类构造方法，重载的比较符`==`和`!=`，序列化的方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<code>COutPoint</code>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** An outpoint - a combination of a transaction hash and an index n into its vout */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">COutPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Txid hash;</span><br><span class="line">    <span class="type">uint32_t</span> n;</span><br><span class="line">    <span class="comment">//... 下面的代码包含了这个类构造方法，重载的比较符`&lt;`,`==`和`!=`，序列化的方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在<code>COutPoint</code>中，我们保存了前一个交易的哈希值。通过这个哈希<code>Txid hash</code>，我们就能找到包含这个输出的交易。然后保存了一个索引<code>uint32_t n</code>。这个索引可以帮助我们找到当前UTXO所使用的是上一笔交易输出中的第几个输出。</p>
<h3 id="交易的验证-比特币脚本">交易的验证 比特币脚本</h3>
<p>比特币中的锁定脚本的生成与验证的方法并不是固定的，比特币为脚本的验证提供一个简单的基于栈的虚拟机。这个虚拟机能够执行一些简单的命令。因此比特币能够执行相对复杂多样的脚本验证，让比特币中的脚本类型多种多样。其中最流行最广泛应用的比特币脚本机制叫做P2PKH和P2SH。</p>
<p>在P2PKH（Pay to Public Key Hash）中，锁定脚本收账人公钥的哈希值，解锁脚本是该UTXO拥有者的签名以及其公钥。例如，Alice想要给Bob转账200个比特币，Alice为了创建这笔交易，她需要先知道Bob的公钥的哈希值。在转账时，Alice需要附上Bob公钥的哈希值以表示这笔钱是转给Bob的。当这比交易被打包上链后，此时Bob就拥有了一个面值200的UTXO。当下次Bob想要花费这个UXTO的时候，他需要附上自己对使用UTXO这笔交易的签名，以及自己的公钥。当网络内有人想要验证Bob这笔交易时，他则可以计算Bob公钥的哈希，同时使用Bob的公钥验证Bob对这笔交易的签名。如果Bob公钥的哈希跟UTXO中的对的上，则证明该UTXO确实属于该公钥所属的账户。如果交易的签名有效，则证明Bob确实是这个账户的拥有者。在实际过程中，如果Alice想要在比特币网络中给Bob转账，那么她需要先一步向Bob请求一些信息。例如在P2PKH中，Alice要先知道Bob的公钥哈希才能给Bob转账。</p>
<p>在执行验证脚本的过程中，验证者会用到验证虚拟机。Alice在转账给Bob时，会在锁定脚本locking script中指定验证脚本的方式。Alice会在锁定脚本中加入验证虚拟机的指令，最后产生的锁定脚本如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG···、、·······</span><br></pre></td></tr></table></figure>
<p>其中<code>OP_DUP</code> <code>OP_HASH160</code>…则是虚拟机内置的指令，而<pubKeyHash>则代表了Bob的公钥，而Bob在花费这个UTXO时，所需提供的解锁脚本，则不包括虚拟机的指令，其示例如下：</pubKeyHash></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;signature&gt; &lt;public key&gt;</span><br></pre></td></tr></table></figure>
<p>验证虚拟机在执行验证时，首先会初始化一个栈，然后分别执行解锁脚本和锁定脚本。其执行过程如下图所式：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1720078566310-c2f1ecb3-5f96-49be-b4a9-b28885654b74.png" alt></p>
<p>其详细执行过程解释如下：</p>
<ol>
<li>先执行解锁脚本，虚拟机将<code>&lt;signature&gt;</code> <code>&lt;public key&gt;</code>分别压入栈， 此时栈内有(左边为栈底，右边为栈口)：</li>
</ol>
<p><code>[&lt;signature&gt; &lt;public key&gt;</code></p>
<ol start="2">
<li>然后执行锁定脚本，执行锁定脚本中的第一个指令：<code>OP_DUP</code>，这个指令将复制栈顶的元素，此时，栈内有：</li>
</ol>
<p><code>[&lt;signature&gt; &lt;public key&gt; &lt;public key&gt;</code></p>
<ol start="3">
<li>虚拟机再执行<code>OP_HASH160</code>，这个操作会对弹出栈顶的第一个元素，对其做哈希运算（先算SHA256，再算RIPEMD-160），最后将运算结果压入栈中。此时栈内：</li>
</ol>
<p><code>[&lt;signature&gt; &lt;public key&gt; &lt;pubKeyHash&gt;</code></p>
<ol start="4">
<li>将锁定脚本中的<code>&lt;pubKeyHash&gt;</code>压入栈中，此时栈内：</li>
</ol>
<p><code>[&lt;signature&gt; &lt;public key&gt; &lt;pubKeyHash&gt;&lt;pubKeyHash&gt;</code></p>
<ol start="5">
<li>执行<code>OP_EQUALVERIFY</code>，这个操作会弹出栈顶两个元素，然后比较他们。如果比较结果是相等，则继续执行。如果不相等，在返回验证失败。此时栈内：</li>
</ol>
<p><code>[&lt;signature&gt; &lt;public key&gt;</code></p>
<ol start="6">
<li>最后执行<code>OP_CHECKSIG</code>，这个操作会依次弹出栈顶的两个元素，弹出的第一个元素作为公钥，第二个元素作为签名，然后验证签名。执行后的结果会被压入栈中，如果为true则代表验证成功。</li>
</ol>
<p><code>[true</code></p>
<p>另一个流行的脚本为P2SH（Pay-to-Script-Hash），在这个脚本中，收账方需要提供一段脚本的哈希作为锁定脚本。在使用UTXO时则需要提供该脚本与运行该脚本所需的额外数据。具体格式如下：</p>
<ul>
<li>锁定脚本：<code>OP_HASH160 &lt;redeemScriptHash&gt; OP_EQUAL</code></li>
<li>解锁脚本： <code>&lt;unlocking data&gt; &lt;redeemScript&gt;</code></li>
</ul>
<p>这里所说的<code>&lt;redeemScript&gt;</code>指的也是比特币脚本，<code>&lt;unlocking data&gt;</code>则指的是签名，公钥等运行脚本所需的数据。当验证者需要验证P2SH脚本时，其不仅要验证脚本本身，还要验证脚本内的<code>&lt;redeemScript&gt;</code>脚本。</p>
<p>除了这些流行的脚本，还有一些比较有意思的脚本，例如多重签名脚本（MultiSig）。要解锁这个脚本，需要收集多方签名。其脚本内容具体如下：</p>
<ul>
<li>解锁脚本：<code>&lt;OP_0&gt; &lt;signature1&gt; &lt;signature2&gt; ...</code></li>
<li>锁定脚本：<code>OP_2 &lt;pubKey1&gt; &lt;pubKey2&gt; &lt;pubKey3&gt; OP_3 OP_CHECKMULTISIG</code></li>
</ul>
<p>例如某些比特币是几个人的共有财产，则可以使用这个脚本。只有当三个人同时允许交易时，交易才能有效。</p>
<h2 id="区块">区块</h2>
<p>比特币中的区块是为是为了打包交易而存在的。比特币中的区块可以保证区块链中已经发生的交易不可篡改，不可撤销。这样就能保证发生过的交易的有效性。当交易双发达成一致后，就会向网络内广播自己的交易，每笔交易内通常有一定数额用于支付给矿工的手续费（即交易输入和输出之间的差距）。网络内的矿工会收集网络内的所有交易（矿工在接收到新的交易后，会将交易储存在本地数据库LevelDB中），并在构造新的区块的时候将其打包至新区块内。这样，矿工就能在网络内协议的允许下，将所有自己所打包的交易的手续费转账给自己。矿工会创建一个新的交易，这个交易没有输入，只有输出。并且，交易的输出数额，是新区块的奖励（例如25个比特币）以及所有所打包的手续费（例如30.124个比特币）之和，输出内的地址是矿工自己的钱包地址（其实是个只有矿工自己能解锁的锁定脚本）。我们把这样的交易叫做Coinbase交易，并且规定Coinbase交易总放在区块链所有所打包的交易的前面，即整个区块的第一个交易。比特币网络中并没有规定区块一定要打包交易，也就是说矿工可以构造一个不携带任何其他交易的新区块。因此我们引入交易手续费作为网络内矿工打包交易的激励之一，这样矿工才更倾向于打包网络内的交易而不是构建空的区块。以下是比特币中，关于区块的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CBlock</span> : <span class="keyword">public</span> CBlockHeader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// network and disk</span></span><br><span class="line">    std::vector&lt;CTransactionRef&gt; vtx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Memory-only flags for caching expensive checks</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> fChecked;                            <span class="comment">// CheckBlock()</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> m_checked_witness_commitment&#123;<span class="literal">false</span>&#125;; <span class="comment">// CheckWitnessCommitment()</span></span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> m_checked_merkle_root&#123;<span class="literal">false</span>&#125;;        <span class="comment">// CheckMerkleRoot()</span></span><br><span class="line">    <span class="comment">// ... 以下是关于BlockerHeader的获取，验证区块，以及序列化等方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>CBlock</code>类是继承至<code>CBlockHeader</code>，这意味着<code>CBlock</code>同样也包含<code>CBlockHeader</code>内的属性。<code>CblockHeader</code>的代码如下（这部分代码违反了“组合优于继承的原则”，不是很好读）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Nodes collect new transactions into a block, hash them into a hash tree,</span></span><br><span class="line"><span class="comment"> * and scan through nonce values to make the block&#x27;s hash satisfy proof-of-work</span></span><br><span class="line"><span class="comment"> * requirements.  When they solve the proof-of-work, they broadcast the block</span></span><br><span class="line"><span class="comment"> * to everyone and the block is added to the block chain.  The first transaction</span></span><br><span class="line"><span class="comment"> * in the block is a special one that creates a new coin owned by the creator</span></span><br><span class="line"><span class="comment"> * of the block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBlockHeader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// header</span></span><br><span class="line">    <span class="type">int32_t</span> nVersion;</span><br><span class="line">    uint256 hashPrevBlock;</span><br><span class="line">    uint256 hashMerkleRoot;</span><br><span class="line">    <span class="type">uint32_t</span> nTime;</span><br><span class="line">    <span class="type">uint32_t</span> nBits;</span><br><span class="line">    <span class="type">uint32_t</span> nNonce;</span><br><span class="line">    <span class="comment">// ... 下面的方法包括了序列化，各种属性的Getter等方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下以上代码，一个区块内包含的信息如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>区块信息</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>区块头</td>
<td><code>int32_t nVersion</code></td>
<td>版本信息，比特币协议可能会随着时间升级</td>
</tr>
<tr>
<td></td>
<td><code>uint256 hashPrevBlock</code></td>
<td>前一个区块的哈希值</td>
</tr>
<tr>
<td></td>
<td><code>uint256 hashMerkleRoot</code></td>
<td>一个哈希值，叫默克尔树树根，从区块体内所有交易的哈希值而来，确保了区块内交易的有效</td>
</tr>
<tr>
<td></td>
<td><code>uint32_t nTime</code></td>
<td>一个Unix时间戳，代表这个区块在挖出来时的时间</td>
</tr>
<tr>
<td></td>
<td><code>uint32_t nBits</code></td>
<td>代表了矿工在挖当前区块时网络中的挖矿难度</td>
</tr>
<tr>
<td></td>
<td><code>uint32_t nNonce</code></td>
<td>一个用于挖矿的随机数字</td>
</tr>
<tr>
<td>区块体</td>
<td><code>std::vector&lt;CTransactionRef&gt; vtx</code></td>
<td>一个保存了所有交易的数组</td>
</tr>
</tbody>
</table>
<p>比特币区块的版本和交易的版本一样，是随着时间动态升级的。同时版本的改变，也会带来链分叉、社区分裂等诸多问题。比特币中，每一个区块内的都保存了前一个区块的哈希值。一旦之前有一个区块的哈希值改变了，其后面所有的区块哈希值都会改变。这样当我们拥有了一个区块，并且确认这个去区块是可信的之后，我们就能挨个往前检查所有区块，并且不用担心区块是被伪造的。这样就形成了一个由区块组成的链条，我们把这种数据结构叫做区块链。我们可以随着这个链往前一直追溯到整个链开始的地方，网络中的用户只要拥有一个可信的区块，就能通过密码学原理保证这个区块前所有区块的可信性。这个机制大大减少了网络内信任的成本。整个比特币网络中的区块链开始的区块是由中本聪（Satoshi Nakamoto）在 2009年1月3日创立的，我们把这个区块称作创世区块（Genesis Block）。如果有人想要伪造另一条完整且有效的链，他需要足够的计算资源完成自2009年1月3日以来，所有矿工完成的工作量——这在现有的物理条件下是几乎不可能的，只有未来当量子计算机大规模普及后才有可能对使用PoW算法（即我们常说的挖矿算法）的区块链造成毁坏。并且，如果真的有机构或者个人拥有这么庞大的计算资源，那么其加入比特币网络会比破坏比特币网络拥有更多收益（这个以下会讨论）。</p>
<h3 id="默克尔树-Merkle-Tree">默克尔树 Merkle Tree</h3>
<p><code>uint256 hashMerkleRoot</code>这个字段是一个哈希值，其代表了一个数据结构默克尔树（Merkle Tree）的根节点。默克尔树是一个由哈希值组成的类似完全二叉树的数据结构。默克尔树可以保证区块内所有所打包交易的完整性（Integrity），同时默克尔树这样的数据结构还能帮助验证者快速验证任何一个交易的完整性（Integrity）。</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1719889934138-b88445b9-6f6d-4997-a3f2-a17dcb7a4be9.jpeg" alt></p>
<p>默克尔根的计算过程如下：</p>
<ol>
<li>例如我们现在区块内有 <img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/b58596e3cc382e9fbe1aa98ef5a8c8b1.svg" alt="image">四个交易</li>
<li>首先我们的分别计算四个交易的哈希值 <img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/b42eab265c8b60abf3499a8d263598ab.svg" alt="image"></li>
<li>接着，我们计算 <img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/76400f1101e4e9d950fc69f510def68d.svg" alt="image">等两两拼接起来的哈希值；如果这一步只有奇数个哈希值，那么，两两配对的时候会多出一个哈希值来，此时我们计算其和自己拼接起来的哈希值，即<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/26b73c46de492f20fc2caf76fd9e15d8.svg" alt="image">。其中<code>||</code>符号代表了简单的拼接操作，例如，<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/06eee2e69e1edf76262cc40c44aa6727.svg" alt="image"></li>
<li>我们可以重复以上步骤，直到最后所有的哈希值都被聚合称一个哈希值（在上例中，即为 <img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/b95fc29c94b3877cc8ad92ea049269cd.svg" alt="image">），我们称最后的哈希值为默克尔树的根。而我们刚刚构建出来的树状数据结构为默克尔树。</li>
</ol>
<p>当区块内的任何一个交易被改变，都会引起默克尔树根的改变。因此，只要保证了默克尔树根的有效，我们就能保证整个区块内的交易数据不被篡改。当我们想校验其中一个交易<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/7f880d21c076059f6644802ba3287318.svg" alt="image">时，我们只需要重新计算<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/752a424c990eaaa83644fe6498c32c80.svg" alt="image">这三步操作，减少的校验的步骤。</p>
<p>以下是比特币中，关于计算默克尔树的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint256 <span class="title">ComputeMerkleRoot</span><span class="params">(std::vector&lt;uint256&gt; hashes, <span class="type">bool</span>* mutated)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> mutation = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (hashes.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mutated) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> pos = <span class="number">0</span>; pos + <span class="number">1</span> &lt; hashes.<span class="built_in">size</span>(); pos += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hashes[pos] == hashes[pos + <span class="number">1</span>]) mutation = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hashes.<span class="built_in">size</span>() &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            hashes.<span class="built_in">push_back</span>(hashes.<span class="built_in">back</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">SHA256D64</span>(hashes[<span class="number">0</span>].<span class="built_in">begin</span>(), hashes[<span class="number">0</span>].<span class="built_in">begin</span>(), hashes.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line">        hashes.<span class="built_in">resize</span>(hashes.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mutated) *mutated = mutation;</span><br><span class="line">    <span class="keyword">if</span> (hashes.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">uint256</span>();</span><br><span class="line">    <span class="keyword">return</span> hashes[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">uint256 <span class="title">BlockMerkleRoot</span><span class="params">(<span class="type">const</span> CBlock&amp; block, <span class="type">bool</span>* mutated)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;uint256&gt; leaves;</span><br><span class="line">    leaves.<span class="built_in">resize</span>(block.vtx.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> s = <span class="number">0</span>; s &lt; block.vtx.<span class="built_in">size</span>(); s++) &#123;</span><br><span class="line">        leaves[s] = block.vtx[s]-&gt;<span class="built_in">GetHash</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ComputeMerkleRoot</span>(std::<span class="built_in">move</span>(leaves), mutated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比特币中的源码提及，这样的算法可能会导致一个致命的漏洞：当区块中的交易数量为奇数时，打包交易的矿工会将其中的一个分支复制一次后计算哈希值。例如以下例子中，当区块内打包的交易为<code>[1,2,3,4,5,6]</code>时，其生成的默克尔根和打包交易为<code>[1,2,3,4,5,6,5,6]</code>没有区别。但是当交易为 <code>[1,2,3,4,5,6,5,6]</code> 的时候，其他的矿工不会承认这个新的区块，因为区内有重复的交易，这样会产生两个相同UTXO。攻击者可以通过向网络内广播<code>[1,2,3,4,5,6,5,6]</code>这个区块，导致这个区块被其他矿工拒收。之后当矿工接受到 <code>[1,2,3,4,5,6]</code>这个诚信的区块时，矿工通过比较区块头发现这个区块和之前拒收的区块区块头一样，是同一个区块。这时矿工就会拒收这个区块，导致网络内诚实的区块不被承认。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       A               A</span><br><span class="line">     /  \            /   \</span><br><span class="line">   B     C         B       C</span><br><span class="line">  / \    |        / \     / \</span><br><span class="line"> D   E   F       D   E   F   F</span><br><span class="line">/ \ / \ / \     / \ / \ / \ / \</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>     <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="PoW-算法">PoW 算法</h3>
<p>以上区块字段中，<code>uint32_t nBits</code>和<code>uint32_t nNonce</code>都是跟PoW算法相关的字段，第一个字段<code>nBits</code>决定了挖矿的难度；而另一个字段<code>nNounce</code>，是一个随机数。矿工需要通过不断调整这个字段来得到一个新的哈希值，直到找到一个哈希值满足挖矿难度。PoW，Proof of Work，工作量证明，同时也是我们通常说的挖矿，是一个求解困难，但是验证容易的算法。在比特币网络中，矿工们需要通过不断调整<code>nNounce</code>字段，计算区块头的哈希值（在实际代码中，是对区块头进行两次SHA256哈希运算。即对原先的区块头进行SHA256运算，得到一个256位的哈希值，再对256位的哈希值再进行一个SHA256运算），以期待找到一个哈希值可以比目标挖矿难度更小的哈希值。有的时候，即使遍历完所有可能的<code>nNounce</code>也找不到一个有效的哈希值，这时矿工需要调整区块内其他数据来继续挖矿，例如重新选择要打包的交易，或者更新时间戳。但验证者只需要将整个区块头哈希一次，就能验证区块的有效性。</p>
<p>目标难度的哈希值，是通过<code>nBits</code>字段计算得到到。<code>nBits</code>是一个32位的二进制无符号整型，其是目标难度的压缩表示。我们通过以下步骤计算出目标难度：</p>
<ol>
<li>我们把这个32位无符号整型分为四个字节 <img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1becf94a458da89497059c47a43c858a.svg" alt="image">,<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/99b74c73e8f07cc892af007b651fce09.svg" alt="image">,<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/d40c1d2b091917790d7ccebbf0fa100f.svg" alt="image">,<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/caae91dcdbd84af6e6f34788915700ac.svg" alt="image">，例如 <code>nBits = 0x1b0404cb</code>,那么 :</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1becf94a458da89497059c47a43c858a.svg" alt="image">=0x1b,<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/99b74c73e8f07cc892af007b651fce09.svg" alt="image">=0x04,<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/d40c1d2b091917790d7ccebbf0fa100f.svg" alt="image">=0x04,<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/caae91dcdbd84af6e6f34788915700ac.svg" alt="image">=0xcb</p>
<ol start="2">
<li>计算目标难度，即：</li>
</ol>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/86366b27f6f9b53bb64b0b9d045a97cf.svg" alt="image"></p>
<p>在这个例子中，即：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/ec7c8edb5e9fd3ad668a428e644aac66.svg" alt="image"></p>
<p>比特币中，压缩表示<code>nBits</code>与<code>target difficulty</code>互相转换的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从压缩表示转换称目标难度</span></span><br><span class="line"><span class="comment">// This implementation directly uses shifts instead of going</span></span><br><span class="line"><span class="comment">// through an intermediate MPI representation.</span></span><br><span class="line"><span class="function">arith_uint256&amp; <span class="title">arith_uint256::SetCompact</span><span class="params">(<span class="type">uint32_t</span> nCompact, <span class="type">bool</span>* pfNegative, <span class="type">bool</span>* pfOverflow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nSize = nCompact &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="type">uint32_t</span> nWord = nCompact &amp; <span class="number">0x007fffff</span>;</span><br><span class="line">    <span class="keyword">if</span> (nSize &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        nWord &gt;&gt;= <span class="number">8</span> * (<span class="number">3</span> - nSize);</span><br><span class="line">        *<span class="keyword">this</span> = nWord;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *<span class="keyword">this</span> = nWord;</span><br><span class="line">        *<span class="keyword">this</span> &lt;&lt;= <span class="number">8</span> * (nSize - <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pfNegative)</span><br><span class="line">        *pfNegative = nWord != <span class="number">0</span> &amp;&amp; (nCompact &amp; <span class="number">0x00800000</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pfOverflow)</span><br><span class="line">        *pfOverflow = nWord != <span class="number">0</span> &amp;&amp; ((nSize &gt; <span class="number">34</span>) ||</span><br><span class="line">                                     (nWord &gt; <span class="number">0xff</span> &amp;&amp; nSize &gt; <span class="number">33</span>) ||</span><br><span class="line">                                     (nWord &gt; <span class="number">0xffff</span> &amp;&amp; nSize &gt; <span class="number">32</span>));</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从目标难度转换为压缩表示</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">arith_uint256::GetCompact</span><span class="params">(<span class="type">bool</span> fNegative)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> nSize = (<span class="built_in">bits</span>() + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">    <span class="type">uint32_t</span> nCompact = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nSize &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        nCompact = <span class="built_in">GetLow64</span>() &lt;&lt; <span class="number">8</span> * (<span class="number">3</span> - nSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arith_uint256 bn = *<span class="keyword">this</span> &gt;&gt; <span class="number">8</span> * (nSize - <span class="number">3</span>);</span><br><span class="line">        nCompact = bn.<span class="built_in">GetLow64</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The 0x00800000 bit denotes the sign.</span></span><br><span class="line">    <span class="comment">// Thus, if it is already set, divide the mantissa by 256 and increase the exponent.</span></span><br><span class="line">    <span class="keyword">if</span> (nCompact &amp; <span class="number">0x00800000</span>) &#123;</span><br><span class="line">        nCompact &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">        nSize++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>((nCompact &amp; ~<span class="number">0x007fffffU</span>) == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(nSize &lt; <span class="number">256</span>);</span><br><span class="line">    nCompact |= nSize &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    nCompact |= (fNegative &amp;&amp; (nCompact &amp; <span class="number">0x007fffff</span>) ? <span class="number">0x00800000</span> : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> nCompact;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矿工在挖矿时，必须找到一个哈希值，使其小于目标目标难度，即这里的<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/487f7571224eea42d73503d01c310f91.svg" alt="image">。以下是关于检查区块中PoW是否有效的算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CheckProofOfWork</span><span class="params">(uint256 hash, <span class="type">unsigned</span> <span class="type">int</span> nBits, <span class="type">const</span> Consensus::Params&amp; params)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> fNegative;</span><br><span class="line">    <span class="type">bool</span> fOverflow;</span><br><span class="line">    arith_uint256 bnTarget;</span><br><span class="line"></span><br><span class="line">    bnTarget.<span class="built_in">SetCompact</span>(nBits, &amp;fNegative, &amp;fOverflow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check range</span></span><br><span class="line">    <span class="keyword">if</span> (fNegative || bnTarget == <span class="number">0</span> || fOverflow || bnTarget &gt; <span class="built_in">UintToArith256</span>(params.powLimit))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check proof of work matches claimed amount</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UintToArith256</span>(hash) &gt; bnTarget)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在比特币中，挖矿的难度是动态调整的，每隔2016个区块调整一次。比特币网络，通过动态调整挖矿难度，将每一个区块的生成时间控制在10分钟左右。这样就可以确保比特币网络中的交易以一个固定的速率打包。比特币将每个区块最最大大小限制在1 Mb，也就是说一个区块最多能打包 2000 到 3000 笔交易。我们可以通过这个数据估算出，比特币网络处理交易的速度大概是每秒处理3.34 到 5笔交易，即 3.34 Tps ~ 5 Tps（Transaction per second）。这样的交易处理速度是远远赶不上如今主流网购网站的交易速度（例如每年双11每秒交易成交量可达60万笔，即 600000Tps）。因此，比特币远远称不上是一个实用的电子支付系统。比特币网络中条件挖矿难度的算法如下：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/c923d5efe57437d458789020941002c1.svg" alt="image"></p>
<p>即网络中算力越多，挖矿难度越大；网络中算力越少，挖矿难度越低。网络中每个人实际挖到区块的可能性等于其算力在网络中的占比。</p>
<h3 id="coinbase交易">coinbase交易</h3>
<p>在比特币协议里，我们约定俗成每个区块的第一个交易为coinbase交易，用来奖励矿工付出的工作量。这个交易没有输入，只有输出。用来奖励矿工的奖励币分为两种，分别是所有交易的手续费，以及补贴。交易手续费为所有打包交易的输入和输出之间的差额；补贴即为新发行的比特币，比特币通过这种方式向网络中发行新的货币。交易的补贴会随着区块的整张逐渐减少到0，在挖矿补贴减少到0后，矿工打包新区块的收益就只剩下交易手续费。</p>
<p>在比特币中，如果当前新挖出来的区块被网络内的成员普遍认可，那么在下一个区块的开采中，新的区块就会被添加到我们刚挖出来的这个区块的后面。我把这种情况叫做我们的区块收到了一个确认（confirmation）。比特币协议规定，所有coinbase交易产生的UTXO，必须收到100个确认后才能被花出。而社区内为了确保交易的安全，也规定所有常规的UTXO，即普通交易产生的UTXO，必须在收到6个确认后才能被花出。</p>
<p>区块的奖励每过 210000 个区块减半一次，并且中本聪在2009年开采第一个区块时，将奖励定在了50个比特币。于是比特币网络中所有比特币数量可以表示为：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/7729dd37df3fbf0f55140972e5f2166f.svg" alt="image"></p>
<p>这是一个收敛的几何无穷级数，其收敛于<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/76a403427351156568b2dc19a7ccaf2b.svg" alt="image">，即网络中比特币的总量为固定的 21 000 000 枚。这个性质赋予比特币类似黄金的金融属性——限量，稀有。以下是比特币中相关源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CAmount <span class="title">GetBlockSubsidy</span><span class="params">(<span class="type">int</span> nHeight, <span class="type">const</span> Consensus::Params&amp; consensusParams)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> halvings = nHeight / consensusParams.nSubsidyHalvingInterval;</span><br><span class="line">    <span class="comment">// Force block reward to zero when right shift is undefined.</span></span><br><span class="line">    <span class="keyword">if</span> (halvings &gt;= <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    CAmount nSubsidy = <span class="number">50</span> * COIN;</span><br><span class="line">    <span class="comment">// Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.</span></span><br><span class="line">    nSubsidy &gt;&gt;= halvings;</span><br><span class="line">    <span class="keyword">return</span> nSubsidy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>consensusParams.nSubsidyHalvingInterval</code>定义在<code>src/kernel/chainparams.cpp</code>中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CMainParams</span> : <span class="keyword">public</span> CChainParams &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMainParams</span>() &#123;</span><br><span class="line">        <span class="comment">//...省略代码</span></span><br><span class="line">        consensus.nSubsidyHalvingInterval = <span class="number">210000</span>;</span><br><span class="line">        <span class="comment">//...省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间戳以及其验证">时间戳以及其验证</h3>
<p>比特币协议中，验证者要求新产生的区块是时间戳必须大于前11个区块的时间戳中值，小于验证者本地网络时间加上2个小时。其代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Context-dependent validity checks.</span></span><br><span class="line"><span class="comment"> *  By &quot;context&quot;, we mean only the previous block headers, but not the UTXO</span></span><br><span class="line"><span class="comment"> *  set; UTXO-related validity checks are done in ConnectBlock().</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">NOTE:</span> This function is not currently invoked by ConnectBlock(), so we</span></span><br><span class="line"><span class="comment"> *  should consider upgrade issues if we change which consensus rules are</span></span><br><span class="line"><span class="comment"> *  enforced in this function (eg by adding a new consensus rule). See comment</span></span><br><span class="line"><span class="comment"> *  in ConnectBlock().</span></span><br><span class="line"><span class="comment"> *  Note that -reindex-chainstate skips the validation that happens here!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">ContextualCheckBlockHeader</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> CBlockHeader&amp; block, </span></span></span><br><span class="line"><span class="params"><span class="function">    BlockValidationState&amp; state, </span></span></span><br><span class="line"><span class="params"><span class="function">    BlockManager&amp; blockman, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> ChainstateManager&amp; chainman, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> CBlockIndex* pindexPrev</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span></span><br><span class="line"><span class="function">    <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(::cs_main)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">AssertLockHeld</span>(::cs_main);</span><br><span class="line">    <span class="built_in">assert</span>(pindexPrev != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> nHeight = pindexPrev-&gt;nHeight + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check proof of work</span></span><br><span class="line">    <span class="comment">//...省略代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check against checkpoints</span></span><br><span class="line">    <span class="comment">//...省略代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check timestamp against prev</span></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">GetBlockTime</span>() &lt;= pindexPrev-&gt;<span class="built_in">GetMedianTimePast</span>())</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_INVALID_HEADER, <span class="string">&quot;time-too-old&quot;</span>, <span class="string">&quot;block&#x27;s timestamp is too early&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check timestamp</span></span><br><span class="line">    <span class="keyword">if</span> (block.<span class="built_in">Time</span>() &gt; NodeClock::<span class="built_in">now</span>() + std::chrono::seconds&#123;MAX_FUTURE_BLOCK_TIME&#125;) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_TIME_FUTURE, <span class="string">&quot;time-too-new&quot;</span>, <span class="string">&quot;block timestamp too far in the future&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reject blocks with outdated version</span></span><br><span class="line">    <span class="keyword">if</span> ((block.nVersion &lt; <span class="number">2</span> &amp;&amp; <span class="built_in">DeploymentActiveAfter</span>(pindexPrev, chainman, Consensus::DEPLOYMENT_HEIGHTINCB)) ||</span><br><span class="line">        (block.nVersion &lt; <span class="number">3</span> &amp;&amp; <span class="built_in">DeploymentActiveAfter</span>(pindexPrev, chainman, Consensus::DEPLOYMENT_DERSIG)) ||</span><br><span class="line">        (block.nVersion &lt; <span class="number">4</span> &amp;&amp; <span class="built_in">DeploymentActiveAfter</span>(pindexPrev, chainman, Consensus::DEPLOYMENT_CLTV))) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="built_in">Invalid</span>(BlockValidationResult::BLOCK_INVALID_HEADER, <span class="built_in">strprintf</span>(<span class="string">&quot;bad-version(0x%08x)&quot;</span>, block.nVersion),</span><br><span class="line">                                 <span class="built_in">strprintf</span>(<span class="string">&quot;rejected nVersion=0x%08x block&quot;</span>, block.nVersion));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当矿工想要开始挖矿时，他会从自己数据库中存储的未打包的交易（我们通常称为交易池）中选出一些交易——矿工为了利益最大化，通常会按一定规则选择交易，例如按照手续费的高低，或者每字节的手续费等评判标准——然后计算手续费之和，加上下一个区块的补贴，生成coinbase交易。之后矿工会计算所有交易的默克尔树，接着向网络中核对区块头内其他信息，例如版本，时间，和难度。最后，矿工就可以通过不断调整<code>nNonce</code>以期望找到一个符合目标难度的哈希值。如果该矿工找到了哈希值，那么他就可以向网络内广播自己新挖出的区块，当这个新区块被网络内的大多数节点验证接受后，这个矿工就挖矿成功了，这时，它可以获得这个新区块的所有收益。而当网络内有其他矿工先一步找到下一个区块时，这个矿工就必须放弃之前所有的工作，从交易池中删除已经被打包好的交易，重新选择一些交易。</p>
<p>在现实中，挖矿的收益是非常不确定的。一旦有人先一步找到了一个合法的区块，那么之前所有付出的努力都将白费。因此，在现实中，矿工们会自发的组成矿池，一但某个矿池发现了一个合法的区块，那么挖出该区块所得到的收益都将按照贡献的算力分配给矿池内的每一个矿工。加入矿池并不能提高挖矿收益的期望，但是可以显著降低收益的方差，让挖矿的收益更稳定。</p>
<h2 id="共识算法">共识算法</h2>
<p>区块链网络是由矿工们组成的一个P2P（点对点）网络。在这个网络中，并没有一个处于中心位置的节点。每个网络中的参与者（我们称作节点）都在本地维护了一份公共账本的副本。为了维护一个公共的交易系统，我们需要所有节点的账本保持一致。为了保持网络中所有节点的账本的一致性，网络中的所有参与者需要达成共识。</p>
<p>最简单的共识算法就是一个泛洪算法（没有PoW），每个人在收到区块后向网络内广播自己新收到的区块。为了避免泛滥，每个节点在接受到已接收过的区块时，需要直接丢弃。但这样的网络时十分脆弱的，攻击者不需要任何成本就可以伪造新的区块，一旦有攻击者向网络内广播伪造的新区块，网络内就会达成错误的共识。</p>
<p>在这个算法改进上，我们可以让每个节点从多个来源接受区块，选择相信最多人认可的区块。我们把这样的共识协议称为拜占庭协议。这样的共识网络需要网络内至少<img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/28955ef49943e21c66dc069fc9a1445f.svg" alt="image">的节点是诚实的。但这样的网络容易受到女巫攻击，即攻击者可以一台电脑同时维持多个节点，从而在数量上占优。</p>
<p><font style="color:#000000;">比特币在拜占庭协议上，添加了PoW算法</font>，即攻击者的投票权是通过其在网络中提供的算力占比决定的。我们称这样的共识为中本聪协议。攻击者在产生新的区块时，需要耗费大量算力成本和时间成本，这让攻击者不能轻易伪造区块，同时，多开多个节点也没有意义，一台电脑所能提供的算力是恒定的。这样的共识系统，只用保证网络内51%的节点（其实是拥有该比例算力的节点）是诚实的，就能保证整个系统的安全。</p>
<p><font style="color:#000000;">激励相容机制</font>：中本聪在PoW上，进一步提出用虚拟货币奖励提供算力的挖矿者。这时，即便有人能凭借一己之力拥有网络内一半以上的算力，其遵守网络内的挖矿规则比破坏网络能获得更大的收益，攻击者也没理由破坏整个比特币网络。</p>
<h3 id="共识算法的分叉问题">共识算法的分叉问题</h3>
<p>比特币网络硬性规定，只有最长的点才是合法的链，当同时有两条合法的链存在时，比特币中所有节点都应该保存较长的那一条。当比特币网络中同时有人挖出区块时，网络中其他节点会同时保存两个分支，直到其中一个分支比另一个更长。此时，较短的那条支链会被丢弃，其上打包的所有交易，都应该重新打包。</p>
<p>比特币网络中，协议的改变或许会导致链的分叉和社区分裂。例如，当新的版本发布后，网络内只有一部分矿工升级了节点，那么有可能会导致升级后的节点不承认没有升级的节点挖出来的新区块，或者没有升级的节点不承认升级后的节点挖出来的新区块。这样，他们都会在原有的链上继续挖矿，导致链的分叉。</p>
<p>其中区块链的分链分为硬分叉和软分叉。硬分叉是指由于新旧版本不兼容，导致比特币社区永久分裂，旧版本的节点会在原链上继续挖矿，而新版本的节点则在另一条分支上挖矿。例如，比特币协议版本的升级导致旧版本的节点不认可新版本节点挖出来的区块，但是新版本的节点是兼容旧版本节点挖出来的区块的，这时，新旧版本的节点同时在原有的链尾继续添加区块。当新版本的节点挖出新区块时，旧版本的节点会认为新区块是非法，而旧版本的节点挖出来的区块会被新版本承认。此时新版本的链会更长，因此所有更新的协议的节点都会沿着这个更长的链挖矿，而所有没更新协议的节点，都会沿着另一条分支继续挖矿。</p>
<p>软分叉是指协议升级而导致链的暂时分叉。例如升级协议后的节点不承认旧协议节点挖出来的新区块，但是就旧协议节点承认新协议节点产生出来的新区块。这样新协议节点挖出来的区块会在网络内被认可，而旧协议节点挖出来的区块却一直被抛弃，直到旧协议节点升级其协议。</p>
<h3 id="PoW的51-攻击">PoW的51%攻击</h3>
<p>如果攻击者拥有了整个比特币网络内51% 的算力，那么他可以对整个网络发起51%攻击。攻击者可以通过利用比网络内所有其他人都多的算力，将自己违法的交易打包进区块中，并且在违法区块后不断添加新区块，达到比网络中“诚实链”更长的的长度。这时，网络内所有其他节点都不得不接受更长的“违法链”。通过这种方式，攻击者可以做到:</p>
<ul>
<li>修改自己的交易记录，双花问题</li>
<li>阻止区块确认部分或者全部交易</li>
<li>阻止部分或者全部矿工开采任何有效区块</li>
<li>阻止某些交易进入区块链</li>
</ul>
<p>攻击者不可以做到：</p>
<ul>
<li>修改他人交易记录，把不属于自己的比特币发送给其他人</li>
<li>阻止他人发送交易</li>
<li>改变每个区块比特币产生的数量</li>
<li>凭空产生比特币</li>
</ul>
<p>如果一个攻击者拥有了全网51% 的算例，如果他遵守网络规则，他的收益是：</p>
<ul>
<li>剩下所有的coinbase coin</li>
<li>未来所有的交易费用</li>
<li>需要很长时间才能获取这些收益</li>
</ul>
<p>如果他选择破坏系统，那么他能获取最大收益的方式为，在别人发现前，将自己所有的钱多次花出去（双花/多花攻击）。这样他的收益为：</p>
<ul>
<li>当前手上所有比特币的n倍，保守估计，如果他在第一次实行双花攻击的时候就被人举报，导致网络内信任崩塌，那么他所能拥有的额外收益为当前上手所有比特币的价值。（他能兑现的收益为手上所有比特币和双花攻击给他带来的收益）</li>
<li>相对短时间内就能获取这些收益</li>
</ul>
<p>实际上，当攻击者拥有较少的比特币，那么他破坏网络的收益远赶不上他遵守网络规则的收益；而如果他拥有较多的比特币，那么他一次性将这些比特币全部花出去是不现实的。因此奖励虚拟货币的激励机制进一步强化了比特币网络的健壮性。</p>
<h2 id="比特币网络">比特币网络</h2>
<h3 id="加入网络">加入网络</h3>
<p>比特币中，新节点往往依赖于硬编码在软件内的IP地址加入网络。新节点在第一次启动的时候尝试与硬编码在源码内的地址沟通。在建立连接后，新节点会尝试通过该节点获取网络内其他节点的IP地址，同时向其他节点请求同步网络内区块链的最新状态，这一过程通常需要下载几个GB的数据，是个耗时的过程。同步过程是从最新的区块开始的，然后逐渐向前同步，直到和整个网络中的区块链的状态一致。储存整个区块链的信息开销是巨大的，这样就对成为节点的设备有了限制。中本聪在论问题提出一种新型的轻型节点——SPV——让手机等计算能力有限的设备成为比特币节点成为可能。</p>
<h3 id="轻型节点">轻型节点</h3>
<p>比特币网络中，所有节点可以分为两类：一种是全节点，全节点储存了网络内的所有区块和UTXO；另一种是轻型节点，也叫简单交易验证节点（Simple Payment Verification Node，SPV Node），其值储存区块的区块头和自己的钱包。矿工节点必须是全节点，因为矿工需要依赖存储网络内所有交易来验证打包交易。轻型节点的存在让用手机转账比特币成为可能。</p>
<p>简单交易验证节点SPV正在发起交易时，需要验证交易内作为输入的UTXO是否有效。此时，SPV需要验证作为UTXO来源的交易。简单交易验证节点本身是不储存任何交易和区块的，因此，他需要向任何其他全节点请求UTXO的来源交易。同时，为了验证交易是否真的属于某个区块，它需要向全节点请求该交易到区块的默克尔根的默克尔路径。默克尔路径指得是从交易哈希到默克尔根的的一系列哈希值，例如下图中，想要验证交易1，则需要知道哈希值2，哈希值E，哈希值C（哈希值A是默克尔根，包含在区块头中）。简单交易节点接着就可以通过默克尔证明，证明交易1的有效性。例如通过交易1和交易2的哈希值计算出哈希值D；用哈希值D和哈希值E计算出哈希值B；最后用哈希值B和哈希值C就能计算出哈希值A。（A是已知的默克尔根）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       A</span><br><span class="line">     /  \</span><br><span class="line">   B     C</span><br><span class="line">  / \    |</span><br><span class="line"> D   E   F</span><br><span class="line">/ \ / \ / \</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>  </span><br></pre></td></tr></table></figure>
<p>简单交易节点通过计算一系列哈希运算，就能验证交易的有效性。自此简单交易节点就能够完善自己交易的信息，向网络内广播交易。</p>
<h2 id="比特币存储LevelDB">比特币存储LevelDB</h2>
<p>比特币实际使用LevelDB作为其存储方式。LevelDB是由谷歌开发的一款简单高效的键值对存储数据库。其提供简单操作和高性能的读取:LevelDB提供三种基础操作，<code>Put(key,value)</code>——将数据以键值对的方式存储，<code>Get(key)</code>——通过键去除与其关联的值，和<code>Delete(key)</code>——删除某个键与其相关联的值。这个数据库还提供压缩数据和查看数据库内容的功能。LevelDB在接受到存储请求后，会将数据先存储在内存中的MemTable。当内存中MemTable的数据增长到一定规模，内存中的数据会被打包成一个不可变的SSTable（Sorted String Table）放入磁盘当中。当用户想要修改某个键值对时，这个键值对会直接被写入MemTable。当收到存储请求的时候，LevelDB会从MemTable开始，从较新的SSTable查找到较老的SSTable，这样就能保证查到的值一定是最新的值。为了优化磁盘空间利用率，LevelDB会定期合并磁盘中的SSTable，同时合并的过程中会删去旧的失效键值对。以键值对方式存储的数据库通常不包含数据关系模型，LevelDB也一样，其同时还不提供多进程操作，网络通信等功能。</p>
<p>比特币客户端在收到交易、区块、地址、或者在计算出余额和UTXO后，都会存储在本地数据库当中。比特币不直接将交易储存在数据库中，而是将交易作为区块的一部分，同区块头一起存储在数据库中。存储的区块的时候，使用的键（key）是区块的哈希值，值（value）是区块索引信息，例如区块头，区块高度等信息。比特币会将区块内的UTXO单独提取出来储存，以便在验证UTXO时能快速找到。UTXO在存储时，比特币客户端使用该交易的哈希值作为键（key），交易内所有输出（即该交易包含的所有UTXO）作为值（value）。</p>
<h2 id="补充内容">补充内容</h2>
<h3 id="证书-（补充至第一章）">证书 （补充至第一章）</h3>
<p>从网络上获取的公钥并不能保证其来源的真实性，攻击者可以通过中间人攻击（Man-In-The-Middle Attack，MITM）篡改公钥，从而窃取信息。例如，Alice想要和Bob在互联网中加密通信，于是他们准备互换公钥。这时，攻击者可以伪装成Bob，与Alice互换公钥，同时也伪装成Alice，与Bob互换公钥。Alice发给Bob的信息，这时被发给了攻击者；攻击者将信息解码后，用Bob的公钥加密，再发给Bob。Alice和Bob在这个情况下都可以正常通信，并且对中间的第三者毫不知情。</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1719450008166-7d637862-47ee-477c-950a-f29ddb043664.png" alt></p>
<p>为了避免这种情况，在现代互联网中，我们引入证书机制，来确保从网络获取到的公钥的真实性。即保证从网络中获取到的Alice的公钥，确实属于Alice本人。当Alice向互联网上其他人传输自己的公钥时，Alice还需要传输一份与她公钥相关联的电子证书。接受者只需要验证证书的真伪，就能确定Alice公钥的真实性。公钥的证书内容通常包括Alice的公钥，Alice的身份信息，证书的有效期，和证书的签名。验证证书的过程，即为验证证书电子签名的过程。证书的签名是电子签名，通常是由权威机构（Certificate Authority，CA）签下的。在验证证书的签名时，验证者需要获取签名机构的公钥。权威机构的公钥通常属于网络内的共识，难以被伪冒。</p>
<p>单个签名机构很难满足整个互联网的证书需求。为了满足整个互联网的证书需求，签名机构被拓展为树状层级结构。在这个树结构中，每个叶节点（最底层的节点）都可以给其他机构颁发证书，而叶节点的证书，是由上层签名机构颁发的。</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1719450330532-74fb9d99-89f4-40da-b9eb-5444cff7daaa.png" alt></p>
<p>Alice在生成其公钥的时候，需要向在叶节点的证书权威机构CA申请其公钥的证书。在权威机构批准后，Alice就能获得与其公钥相关联的证书。当Bob向Alice请求Alice的公钥时，Alice就可以出示证书来证明其公钥的真实性。当Bob想要验证Alice的证书时，他首先需要验证Alice签名机构的证书；而验证Alice签名机构的证书，则要验证其签名机构的签名机构的证书…直到追踪到整个树的根签名机构。根签名机构（Root CA）的公钥则是网络内共识。</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1719451818964-695cb156-4882-4dec-9988-402684788b65.png" alt></p>
<p>证书被广泛应用于现代互联网中，现在带几乎所有使用HTTPS链接的网站，都有证书。以下是我正在编辑这段文字时，所使用的语雀网站的证书：</p>
<p><img src="images/%E6%AF%94%E7%89%B9%E5%B8%81/1719394592748-9fe1185c-14e7-4fb0-9d15-608dba129244.png" alt></p>
<h3 id></h3>
</div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">nty</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Nie-Tianyi"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/%E4%BB%80%E4%B9%88%E6%98%AFHadoop_preprocessed/" title="Hadoop">Hadoop</a><time datetime="2025-09-14T12:46:25.000Z" title="发表于 2025-09-14 20:46:25">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/12/Raft%E5%8D%8F%E8%AE%AE_preprocessed/" title="Raft协议">Raft协议</a><time datetime="2025-09-12T12:46:25.000Z" title="发表于 2025-09-12 20:46:25">2025-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/07/Lecture%201_preprocessed/" title="凸函数优化笔记（1）">凸函数优化笔记（1）</a><time datetime="2025-09-07T12:46:25.000Z" title="发表于 2025-09-07 20:46:25">2025-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/27/%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89_preprocessed/" title="线性函数定义">线性函数定义</a><time datetime="2025-08-27T12:46:25.000Z" title="发表于 2025-08-27 20:46:25">2025-08-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C's%20Gradient_preprocessed/" title="神经网络's Gradient">神经网络's Gradient</a><time datetime="2025-08-16T12:46:25.000Z" title="发表于 2025-08-16 20:46:25">2025-08-16</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Hadoop/" style="font-size: 1.1em; color: #999">Hadoop</a> <a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 1.1em; color: #999">人工智能</a> <a href="/tags/Python/" style="font-size: 1.3em; color: #99a1ac">Python</a> <a href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" style="font-size: 1.1em; color: #999">异步编程</a> <a href="/tags/%E4%BA%8C%E5%B1%82%E6%89%A9%E5%B1%95/" style="font-size: 1.1em; color: #999">二层扩展</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 1.1em; color: #999">性能优化</a> <a href="/tags/PostgreSQL/" style="font-size: 1.1em; color: #999">PostgreSQL</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0/" style="font-size: 1.1em; color: #999">线性函数</a> <a href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" style="font-size: 1.2em; color: #999da3">以太坊</a> <a href="/tags/PyO3/" style="font-size: 1.1em; color: #999">PyO3</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 1.1em; color: #999">大数据</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" style="font-size: 1.1em; color: #999">编程基础</a> <a href="/tags/%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/" style="font-size: 1.1em; color: #999">共识协议</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" style="font-size: 1.1em; color: #999">线性回归</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 1.4em; color: #99a5b6">区块链</a> <a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.1em; color: #999">数学</a> <a href="/tags/%E6%AF%94%E7%89%B9%E5%B8%81/" style="font-size: 1.1em; color: #999">比特币</a> <a href="/tags/Rust/" style="font-size: 1.4em; color: #99a5b6">Rust</a> <a href="/tags/Web%E6%A1%86%E6%9E%B6/" style="font-size: 1.1em; color: #999">Web框架</a> <a href="/tags/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81/" style="font-size: 1.1em; color: #999">加密货币</a> <a href="/tags/SQL/" style="font-size: 1.1em; color: #999">SQL</a> <a href="/tags/Axum/" style="font-size: 1.1em; color: #999">Axum</a> <a href="/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/" style="font-size: 1.4em; color: #99a5b6">梯度下降</a> <a href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" style="font-size: 1.1em; color: #999">智能合约</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/" style="font-size: 1.1em; color: #999">数据科学</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" style="font-size: 1.3em; color: #99a1ac">分布式系统</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/" style="font-size: 1.1em; color: #999">逻辑回归</a> <a href="/tags/Raft/" style="font-size: 1.1em; color: #999">Raft</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 1.1em; color: #999">线程池</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 1.1em; color: #999">并发编程</a> <a href="/tags/numba/" style="font-size: 1.1em; color: #999">numba</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.1em; color: #999">数据库</a> <a href="/tags/Python%E8%AF%AD%E6%B3%95/" style="font-size: 1.1em; color: #999">Python语法</a> <a href="/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" style="font-size: 1.1em; color: #999">共识算法</a> <a href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" style="font-size: 1.1em; color: #999">神经网络</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 1.5em; color: #99a9bf">机器学习</a> <a href="/tags/Tokio/" style="font-size: 1.1em; color: #999">Tokio</a> <a href="/tags/%E5%87%B8%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96/" style="font-size: 1.1em; color: #999">凸函数优化</a></div></div><div class="card-widget card-archives">
    <div class="item-headline">
      <i class="fas fa-archive"></i>
      <span>归档</span>
      <a class="card-more-btn" href="/archives/"
            title="查看更多">
            <i class="fas fa-angle-right"></i>
          </a>
    </div>
  
    <ul class="card-archive-list">
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/09/">
            <span class="card-archive-list-date">
              九月 2025
            </span>
            <span class="card-archive-list-count">3</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/08/">
            <span class="card-archive-list-date">
              八月 2025
            </span>
            <span class="card-archive-list-count">3</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/07/">
            <span class="card-archive-list-date">
              七月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/06/">
            <span class="card-archive-list-date">
              六月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/05/">
            <span class="card-archive-list-date">
              五月 2025
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2025/03/">
            <span class="card-archive-list-date">
              三月 2025
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/10/">
            <span class="card-archive-list-date">
              十月 2024
            </span>
            <span class="card-archive-list-count">1</span>
          </a>
        </li>
      
        <li class="card-archive-list-item">
          <a class="card-archive-list-link" href="/archives/2024/09/">
            <span class="card-archive-list-date">
              九月 2024
            </span>
            <span class="card-archive-list-count">2</span>
          </a>
        </li>
      
    </ul>
  </div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">19</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总浏览量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-09-16T17:46:14.948Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By nty</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>