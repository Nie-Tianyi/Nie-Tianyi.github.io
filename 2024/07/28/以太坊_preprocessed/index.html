<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>以太坊 | nty的技术博客</title><meta name="author" content="nty"><meta name="copyright" content="nty"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="以太坊诞生于2014年。2014年，19岁的Vitalik Buterin率先在一片文章中提出针对比特币的改进以及对区块链未来的构想。这篇文章中提出可以针对比特币的脚本验证中所使用的栈虚拟机做出改进，以建造一个图灵完备的虚拟机。这样，区块链中的虚拟机将不再局限于脚本的验证，而是可以执行任何计算机能完成的程序。这样的区块链可以作为其他区块链应用的载体，还可以支持一条链上不同区块链应用之间的互相操作。">
<meta property="og:type" content="article">
<meta property="og:title" content="以太坊">
<meta property="og:url" content="https://nie-tianyi.github.io/2024/07/28/%E4%BB%A5%E5%A4%AA%E5%9D%8A_preprocessed/index.html">
<meta property="og:site_name" content="nty的技术博客">
<meta property="og:description" content="以太坊诞生于2014年。2014年，19岁的Vitalik Buterin率先在一片文章中提出针对比特币的改进以及对区块链未来的构想。这篇文章中提出可以针对比特币的脚本验证中所使用的栈虚拟机做出改进，以建造一个图灵完备的虚拟机。这样，区块链中的虚拟机将不再局限于脚本的验证，而是可以执行任何计算机能完成的程序。这样的区块链可以作为其他区块链应用的载体，还可以支持一条链上不同区块链应用之间的互相操作。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nie-tianyi.github.io/images/avatar.png">
<meta property="article:published_time" content="2024-07-28T12:46:25.000Z">
<meta property="article:modified_time" content="2024-07-28T12:46:25.000Z">
<meta property="article:author" content="nty">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="以太坊">
<meta property="article:tag" content="智能合约">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nie-tianyi.github.io/images/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "以太坊",
  "url": "https://nie-tianyi.github.io/2024/07/28/%E4%BB%A5%E5%A4%AA%E5%9D%8A_preprocessed/",
  "image": "https://nie-tianyi.github.io/images/avatar.png",
  "datePublished": "2024-07-28T12:46:25.000Z",
  "dateModified": "2024-07-28T12:46:25.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "nty",
      "url": "https://nie-tianyi.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://nie-tianyi.github.io/2024/07/28/%E4%BB%A5%E5%A4%AA%E5%9D%8A_preprocessed/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '以太坊',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">nty的技术博客</span></a><a class="nav-page-title" href="/"><span class="site-name">以太坊</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">以太坊</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-28T12:46:25.000Z" title="发表于 2024-07-28 20:46:25">2024-07-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-28T12:46:25.000Z" title="更新于 2024-07-28 20:46:25">2024-07-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>以太坊诞生于2014年。2014年，19岁的Vitalik Buterin率先在一片文章中提出针对比特币的改进以及对区块链未来的构想。这篇文章中提出可以针对比特币的脚本验证中所使用的栈虚拟机做出改进，以建造一个图灵完备的虚拟机。这样，区块链中的虚拟机将不再局限于脚本的验证，而是可以执行任何计算机能完成的程序。这样的区块链可以作为其他区块链应用的载体，还可以支持一条链上不同区块链应用之间的互相操作。这个想法得到了Gavin Wood的支持，并且在同年2014年上半年，Gavin Wood发表了一份详细的关于新区块链的技术规范，并且在2014年下半年，Gavin Wood用C++开发出了以太坊的第一个客户端。</p>
<p>以太坊不仅维持了一套支付的电子货币系统，还有一整套于其上建立的软件生态。我们把以太坊中运行的虚拟机叫做EVM，把在EVM上运行的程序叫做智能合约。以太坊所有设计，都是围绕智能合约展开的。智能合约能做到很多原生计算机程序能做到的事情：例如自动支付、代币发行、数字资产转移、版权保护等的功能。</p>
<p>以太坊诞生至今，经历了多次迭代更新。以太坊第一个正式的客户端于2015年发布，2016年，以太坊上的热门智能合约TheDAO由于代码漏洞，被黑客攻击。黑客利用漏洞盗取了TheDAO合约中<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/eb3d80abcf6148a8b3f40a922429b3c5.svg" alt="image">的以太币，这些以太币占总以太币发行量的5%。这次攻击使得以太币价格大跌。以太坊社区为了补救这次攻击，于是集体投票决定回滚以太坊主链。但回滚的决定并没有收到所有人的支持，仍有一小部分人决定再旧链上继续挖矿。这使得以太坊社区分裂为两个社区，一个叫ETH，另一个叫ETC。之后，以太坊从2020开始实验使用PoS算法代替PoW算法，并且之后于2022年，由传统的PoW工作量证明机制全面转换为PoS权益证明机制，解决了区块链能源浪费的问题。以太坊至今仍在经历重大迭代更新，预计在近年，完成对网络的扩容升级，增加整个网络处理交易的吞吐量。</p>
<p><img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/1721801138508-9644c04e-8e22-45c1-8d28-7edcf5d49da5.png" alt></p>
<h2 id="用户层">用户层</h2>
<p>与比特币不同的是，以太坊没有使用UTXO作为其交易模型，而是采用传统的记账方式，在账本上直接记录每个人的账户余额，这种交易模式与现代银行转账系统类似。这种基于账户交易模式相比于UTXO，失去了UTXO中能追踪每一笔转账源头的特性，但是这样记账简单明了，符合大多数人的直觉。用户在查阅自己的账户余额时，不需要浪费时间挨个审计每个区块中与自己有关的交易。同时，也和现代银行系统类似的是，以太坊要求身份和账户一一对应。尽管以太坊允许一个人持有多个账户，但是用户在转账或者参与智能合约时，只能使用确定的账户。例如，用户再参与竞标类的智能合约时，不能使用以一个账户竞价，而使用另一个账户付款或者退款。以太坊中的交易账户是非匿名的，以太坊中的转账需要在交易中明确表明转账地址，而不是添加一个没有明确指向的锁定脚本。</p>
<p>在攻击UTXO系统时，我们可以使用双花攻击，类似的，在攻击以太坊的交易模型时，我们可以使用重放攻击。例如，Alice给Bob转账了100元，那么Bob可以在网络内广播两次这笔转账。这样在验证者看来，Alice给Bob转账了两次，总计200元。为了防御这种攻击，我们在每个账户中添加一个字段<code>nonce</code>，这个字段代表账户交易的次数。这样每笔交易对应了唯一的<code>nonce</code>，攻击者就难以重放交易。</p>
<h3 id="账户结构">账户结构</h3>
<p>以太坊中存在两类账户，一类叫做外部拥有账户（Externally Owned Account，EOA），账户由用户创建，账户内存储了用户的余额和<code>nonce</code>；另一类叫做智能合约账户（Smart Contract Account），这类账户没有公钥私钥，是由用户创建智能合约的时候自动创建的。智能合约账户也包含了余额和<code>nonce</code>，并且除了这些，还包含了智能合约的代码，以及供代码操作的存储空间。为了账户安全，以太坊硬性规定，合约账户不能主动发起交易，只能被EOA或其他合约调用。以太坊中，EOA账户的地址是由公钥哈希的来的，对公钥进行 Keccak-256 哈希运算 ，然后截取最后20个字节作为EOA账户的地址。合约账户的地址是由创造合约的账户地址和账户交易次数<code>nonce</code>得到。其具体计算过程为：先对EOA账户地址和其交易次数<code>nonce</code>进行RLP编码，例如<code>['0x1234...abcd, 1']</code>；接着，对编码结果进行Keccak-256 哈希运算；最后取哈希值的最后20个字节作为合约账户的地址。以下是go版本以太坊客户端go-ethereum的源码（<a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum.git">https://github.com/ethereum/go-ethereum.git</a>, Accessed on 2024/7/16）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// StateAccount is the Ethereum consensus representation of accounts.</span><br><span class="line">// These objects are stored in the main account trie.</span><br><span class="line">type StateAccount struct &#123;</span><br><span class="line">  Nonce    uint64</span><br><span class="line">  Balance  *uint256.Int</span><br><span class="line">  Root     common.Hash // merkle root of the storage trie</span><br><span class="line">  CodeHash []byte</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>Nonce</code>是每个账户的交易次数；<code>Balance</code>是账户余额，是一个256位的无符号整数；而<code>CodeHash</code>是智能合约的哈希值。智能合约用Solidity语言编写，编写后，需要编译成EVM字节码才能运行在EVM上，这里的哈希值，其实指的是EVM字节码的哈希值。<code>Root</code>是指合约账户中存储的MPT Root，以太坊中所有与存储相关的数据都用MPT表示其状态。</p>
<h2 id="交易层">交易层</h2>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">改变 EVM 状态的交易需要广播到整个网络。 任何节点都可以广播在以太坊虚拟机上执行交易的请求；此后，验证者将执行交易并将由此产生的状态变化传播到网络的其他部分。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">交易需要付费并且必须包含在一个有效区块中。 为了使本概述更加简洁，我们将另行介绍燃料费和验证。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">所提交的交易包括下列信息：</font></p>
<ul>
<li><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;from&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">- 发送者的地址，该地址将签署交易。 这将是一个外部帐户，因为合约帐户不能发送交易。</font></li>
<li><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;to&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">— 接收地址（如果是外部帐户，交易将传输值。 如果是合约帐户，交易将执行合约代码）</font></li>
<li><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;signature&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">– 发送者的标识符。 当发送者的私钥签署交易并确保发送者已授权此交易时，生成此签名。</font></li>
<li><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;nonce&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">- 一个有序递增的计数器，表示来自帐户的交易数量</font></li>
<li><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;value&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">– 发送者向接收者转移的以太币数量（面值为 WEI，1 个以太币 = 1e+18wei）</font></li>
<li><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;input data&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">– 可包括任意数据的可选字段</font></li>
<li><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;gasLimit&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">– 交易可以消耗的最大数量的燃料单位。</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><a target="_blank" rel="noopener" href="https://ethereum.org/zh/developers/docs/evm/opcodes/"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">以太坊虚拟机</font></a><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">指定每个计算步骤所需的燃料单位</font></li>
<li><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;maxPriorityFeePerGas&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">- 作为小费提供给验证者的已消耗燃料的最高价格</font></li>
<li><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;maxFeePerGas&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> - 愿意为交易支付的每单位燃料的最高费用（包括 </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;baseFeePerGas&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> 和 </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;maxPriorityFeePerGas&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">）</font></li>
</ul>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">交易对象看起来像这样：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  from: &quot;0xEA674fdDe714fd979de3EdF0F56AA9716B898ec8&quot;,</span><br><span class="line">  to: &quot;0xac03bb73b6a9e108530aff4df5077c2b3d481e5a&quot;,</span><br><span class="line">  gasLimit: &quot;21000&quot;,</span><br><span class="line">  maxFeePerGas: &quot;300&quot;</span><br><span class="line">  maxPriorityFeePerGas: &quot;10&quot;</span><br><span class="line">  nonce: &quot;0&quot;,</span><br><span class="line">  value: &quot;10000000000&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">但交易对象需要使用发送者的私钥签名。 这证明交易只可能来自发送者，而不是欺诈。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">Geth 这样的以太坊客户端将处理此签名过程。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">示例</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><a target="_blank" rel="noopener" href="https://ethereum.org/zh/developers/docs/apis/json-rpc/"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">JSON-RPC</font></a><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">调用：</font></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;account_signTransaction&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x1923f626bb8dc025849e00f99c25fe2b2f7fb0db&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;gas&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x55555&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;maxFeePerGas&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;maxPriorityFeePerGas&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xabcd&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x07a565b7ed7d7a678680a4c162885bedbb695fe0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x1234&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">示例响应：</font></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;raw&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xf88380018203339407a565b7ed7d7a678680a4c162885bedbb695fe080a44401a6e4000000000000000000000000000000000000000000000000000000000000001226a0223a7c9bcf5531c99be5ea7082183816eb20cfe0bbc322e97cc5c7f71ab8b20ea02aadee6b34b45bb15bc42d9c09de4a6754e7000908da72d48cc7704971491663&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tx&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;maxFeePerGas&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;maxPriorityFeePerGas&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;gas&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x55555&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;to&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x07a565b7ed7d7a678680a4c162885bedbb695fe0&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xabcd&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;v&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x26&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;r&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x223a7c9bcf5531c99be5ea7082183816eb20cfe0bbc322e97cc5c7f71ab8b20e&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;s&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x2aadee6b34b45bb15bc42d9c09de4a6754e7000908da72d48cc7704971491663&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;hash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0xeba2df809e7a612a0a0d444ccfa5c839624bdc00dd29e3340d46df3870f8a30e&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;raw&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">是采用</font><a target="_blank" rel="noopener" href="https://ethereum.org/zh/developers/docs/data-structures-and-encoding/rlp/"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">递归长度前缀 (RLP)</font></a><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">编码形式的签名交易</font></li>
<li><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;tx&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">是已签名交易的 JSON 形式。</font></li>
</ul>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">如有签名哈希，可通过加密技术证明交易来自发送者并提交网络。</font></p>
<h3 id="font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-data-font-font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-字段-font"><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;data&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">字段</font></h3>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">绝大多数交易都是从外部所有的帐户访问合约。 大多数合约用 Solidity 语言编写，并根据</font><u><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">应用程序二进制接口 (ABI)</font></u><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">解释其</font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;data&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">字段。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">前四个字节使用函数名称和参数的哈希指定要调用的函数。 有时可以使用</font><a target="_blank" rel="noopener" href="https://www.4byte.directory/signatures/"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">本数据库</font></a><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">根据选择器识别函数。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">调用数据的其余部分是参数，</font><a target="_blank" rel="noopener" href="https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">按照应用程序二进制接口规范中的规定进行编码</font></a><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">函数选择器是 </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;0xa9059cbb&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">。 有几个</font><a target="_blank" rel="noopener" href="https://www.4byte.directory/signatures/?bytes4_signature=0xa9059cbb"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">具有此签名的已知函数</font></a><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">。 本例中</font><a target="_blank" rel="noopener" href="https://etherscan.io/address/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48#code"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">合约源代码</font></a><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">已经上传到 Etherscan，所以我们知道该函数是 </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;transfer(address, uint256)&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">其余数据如下：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000000000004f6742badb049791cd9a37ea913f2bac38d01279</span><br><span class="line">000000000000000000000000000000000000000000000000000000003b0559f4</span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">根据应用程序二进制接口规范，整型值（例如地址，它是 20 字节整型）在应用程序二进制接口中显示为 32 字节的字，前面用零填充。 所以我们知道 </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;to&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> 地址是 </font><a target="_blank" rel="noopener" href="https://etherscan.io/address/0x4f6742badb049791cd9a37ea913f2bac38d01279"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">4f6742badb049791cd9a37ea913f2bac38d01279</font></a><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">。 </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;value&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> 是 0x3b0559f4 = 990206452。</font></p>
<h3 id="font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-交易类型-font"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">交易类型</font></h3>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">以太坊有几种不同类型的交易：</font></p>
<ul>
<li><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">常规交易：从一个帐户到另一个帐户的交易。</font></li>
<li><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">合约部署交易：没有“to”地址的交易，数据字段用于合约代码。</font></li>
<li><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">执行合约：与已部署的智能合约进行交互的交易。 在这种情况下，“to”地址是智能合约地址。</font></li>
</ul>
<h3 id="布隆过滤器-bloom-filter">布隆过滤器 Bloom Filter</h3>
<p>布隆过滤器可以帮我们快速查找交易、筛选符合条件的区块，例如，我们要查询所有包含跟自己有关交易的区块，我们只需要查询区块头中的<code>Bloom</code>字段，就可以快速判断一个区块是否符合条件。但是布隆过滤器也有一些缺点，一是其不支持删除操作。每次删除集合中元素时，我们都需要重新计算一个新的<code>Bloom</code>字段，而不是在原先<code>Bloom</code>字段上做删减。二是布隆过滤器有一定假阳性的概率，即可能<code>Bloom</code>字段中表明区块中存在相关交易，但实际上该区块并不包含与自己有关的交易。但是布隆过滤器不存在假阴性，即布隆过滤器过滤掉的区块一定不包含相关交易。<code>Bloom</code>字段的生成算法如下：</p>
<ol>
<li>初始化一个大小合适的二进制向量，例如一个256bit的向量，或者一个512bit的向量。</li>
<li>计算集合内元素的哈希值，并将元素映射在向量中的某个位置，并把向量该位置比特从0反转成1。</li>
</ol>
<p>最后我们可以获得一个由0和1组成的向量。当我们想要验证某个元素是否存在集合中时，我们只需要计算元素的哈希值，并通过相同的映射规则找到布隆过滤器中对应的比特，如果该比特为1，则证明集合中存在该元素。当出现哈希碰撞的时候，多个元素可能会映射到布隆过滤器中的同一位置。如果我们要找的元素恰好和集合内元素出现哈希碰撞，就会导致布隆过滤器出现假阳性。为了解决这个问题，我们可以用个多个哈希函数计算同一个元素的哈希值，分别映射到数组内的多个位置。如果我们删除集合内的元素，我们不能直接删除布隆过滤器中相应的比特（将该比特从1调到0），因为集合内多个元素可能会映射到同一个比特，集合内其他元素也可能映射到这个位置。当然，我们可以将比特改为计数，但是那样布隆过滤器就失去了其简单性。</p>
<p>在以太坊的实际实现中，所有和布隆过滤器相关的函数都在Bloom9.go文件中。	在以太坊的实际实现中，布隆过滤器的长度为256字节，在计算布隆过滤器时，会将交易内容的哈希值映射到向量的中的三个位置：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bloomValues returns the bytes (index-value pairs) to set for the given data</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bloomValues</span><span class="params">(data []<span class="type">byte</span>, hashbuf []<span class="type">byte</span>)</span></span> (<span class="type">uint</span>, <span class="type">byte</span>, <span class="type">uint</span>, <span class="type">byte</span>, <span class="type">uint</span>, <span class="type">byte</span>) &#123;</span><br><span class="line">    sha := hasherPool.Get().(crypto.KeccakState)</span><br><span class="line">    sha.Reset()</span><br><span class="line">    sha.Write(data)</span><br><span class="line">    sha.Read(hashbuf)</span><br><span class="line">    hasherPool.Put(sha)</span><br><span class="line">    <span class="comment">// The actual bits to flip</span></span><br><span class="line">    v1 := <span class="type">byte</span>(<span class="number">1</span> &lt;&lt; (hashbuf[<span class="number">1</span>] &amp; <span class="number">0x7</span>))</span><br><span class="line">    v2 := <span class="type">byte</span>(<span class="number">1</span> &lt;&lt; (hashbuf[<span class="number">3</span>] &amp; <span class="number">0x7</span>))</span><br><span class="line">    v3 := <span class="type">byte</span>(<span class="number">1</span> &lt;&lt; (hashbuf[<span class="number">5</span>] &amp; <span class="number">0x7</span>))</span><br><span class="line">    <span class="comment">// The indices for the bytes to OR in</span></span><br><span class="line">    i1 := BloomByteLength - <span class="type">uint</span>((binary.BigEndian.Uint16(hashbuf)&amp;<span class="number">0x7ff</span>)&gt;&gt;<span class="number">3</span>) - <span class="number">1</span></span><br><span class="line">    i2 := BloomByteLength - <span class="type">uint</span>((binary.BigEndian.Uint16(hashbuf[<span class="number">2</span>:])&amp;<span class="number">0x7ff</span>)&gt;&gt;<span class="number">3</span>) - <span class="number">1</span></span><br><span class="line">    i3 := BloomByteLength - <span class="type">uint</span>((binary.BigEndian.Uint16(hashbuf[<span class="number">4</span>:])&amp;<span class="number">0x7ff</span>)&gt;&gt;<span class="number">3</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i1, v1, i2, v2, i3, v3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合约层">合约层</h2>
<p>以太坊中最重要的功能就是执行智能合约。智能合约是用Solidity编程语言编写，运行在EVM上的一段代码。通过智能合约，我们可以实现一些能自动与以太坊中内容交互的功能，例如以太币自动转账，使用以太币的拍卖，或者发行基于以太币的新加密货币和NFT。Solidity语言是以太坊中官方指定专门用于开发智能合约的编程语言，由以太坊开发团队开发，其在语法上与JavaScript类似，并且内置很多与以太坊交互的接口。在开发后，开发者需要将Solidity语言编译成EVM字节码，然后向0x0这个特殊地址转账来部署智能合约。智能合约的字节码存在于交易的data域内。部署的智能合约会生成一个地址和智能合约账户，这个账户内包含了余额，<code>nonce</code>交易次数，智能合约的字节码，以及供智能合约使用storage。在部署后，以太坊网络中的其他人就可以通过给智能合约账户转账来调用智能合约内的函数。调用智能合约的交易不一定要附带任何以太币，调用者可以叫交易中转账金额设为0。但是调用者在调用智能合约时，必须支付一定的gas费用，以提供一定执行智能合约的劳务费给矿工。</p>
<p>gas费是以太坊中为了避免智能合约出限无限循环而规定的一项制度，任何人在调用智能合约的时候都需要支付一定gas费。智能合约中每一个指令的执行都需要消耗一定数量的gas费用，简单的指令例如加减乘除很便宜，但是复杂的指令路计算哈希值，存储会很贵。用户在发起交易时，需要设置交易头内<code>gas limit</code>字段，设置内容时一个gas费用，例如20000。矿工在收到交易后会将<code>gas limit</code>中设置的gas费用一次性扣除，然后随着每一个指令的执行，计算一定的gas费用。如果交易执行完后，还剩一些gas费，则返还到用户的帐户上；但如果执行中，gas费用不够，则回滚交易状态，并且不返还任何交易费用。不返还任何费用的设计是为了防止DDoS攻击，如果返还交易费用了，攻击者就可以在网络内发布大量的无用交易，照成网络的堵塞。同时区块头内也有一个<code>gas limit</code>字段，则个字段的意思与交易中<code>gas limit</code>字段中的意思大相径庭。交易头中的<code>gas limit</code>时为了限制每个区块内交易数量而设计的，其表示每个区块中所有交易的<code>gas limit</code>的总量的上限。以太坊中并没有像比特币中强制限制每个区块的大小不能大于1Mb，以太坊中矿工可以根据自己的需求调整每个区块的大小（区块头中的<code>gas limit</code>字段），每次可以上调<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/9f4d9516fdf2e202eb8dd23f7bb57177.svg" alt="image">或者下调<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/9f4d9516fdf2e202eb8dd23f7bb57177.svg" alt="image"> ，最后网络中的（区块头中）gas limit会趋向网络中所有矿工觉得合理的水平的平均值。</p>
<p>以太坊中每个矿工都运行了一个EVM，矿工在收到创建智能合约的交易后，每一个矿工都会在本地创建一份智能合约（修改本地状态树的状态）。任何调用智能合约的交易也会被所有矿工执行一遍，同时矿工在执行时收取一定汽油费用。需要注意的时，矿工在收取汽油费时，只是在本地的状态树上修改。当某一个矿工在找到一个合法区块后， 矿工会将执行过的交易，交易的收据连带着区块头中状态树的根哈希值一起发布到网络中。此时其他矿工则需要回退到上一个区块的状态，从上一个区块的状态开始，重新执行一遍新区块内的交易，并将交易gas费转移到挖出新区块的节点的账户上。如果其他矿工在新区块发布之前执行过一些智能合约，则这些执行过的交易需要全部回滚，他们也得不到任何gas费用。</p>
<h3 id="solidity">Solidity</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">  // 拍卖的参数。时间单位是秒。</span><br><span class="line">  address payable public beneficiary;</span><br><span class="line">  uint public auctionEndTime;</span><br><span class="line">  // 当前状态</span><br><span class="line">  address public highestBidder;</span><br><span class="line">  uint public highestBid;</span><br><span class="line">  // 可以取回的以前的出价</span><br><span class="line">  mapping(address =&gt; uint) pendingReturns;</span><br><span class="line">  // 拍卖结束的标志</span><br><span class="line">  bool ended;</span><br><span class="line">  // 拍卖的事件</span><br><span class="line">  event HighestBidIncreased(address bidder, uint amount);</span><br><span class="line">  event AuctionEnded(address winner, uint amount);</span><br><span class="line">  // 参数为拍卖时间 _biddingTime 和受益人地址 _beneficiary 的构造函数</span><br><span class="line">  constructor(</span><br><span class="line">    uint _biddingTime,</span><br><span class="line">    address payable _beneficiary</span><br><span class="line">  ) &#123;</span><br><span class="line">    beneficiary = _beneficiary;</span><br><span class="line">    auctionEndTime = block.timestamp + _biddingTime;</span><br><span class="line">  &#125;</span><br><span class="line">  // 出价函数</span><br><span class="line">  function bid() public payable &#123;</span><br><span class="line">    // 不允许拍卖结束后出价</span><br><span class="line">    require(</span><br><span class="line">      block.timestamp &lt;= auctionEndTime,</span><br><span class="line">      &quot;Auction already ended.&quot;</span><br><span class="line">    );</span><br><span class="line">    // 如果出价不够高，返还出价</span><br><span class="line">    require(</span><br><span class="line">      msg.value &gt; highestBid,</span><br><span class="line">      &quot;There already is a higher bid.&quot;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    if (highestBid != 0) &#123;</span><br><span class="line">      // 返还以前的最高出价</span><br><span class="line">      pendingReturns[highestBidder] += highestBid;</span><br><span class="line">    &#125;</span><br><span class="line">    highestBidder = msg.sender;</span><br><span class="line">    highestBid = msg.value;</span><br><span class="line">    emit HighestBidIncreased(msg.sender, msg.value);</span><br><span class="line">  &#125;</span><br><span class="line">  // 取回出价</span><br><span class="line">  function withdraw() public returns (bool) &#123;</span><br><span class="line">    uint amount = pendingReturns[msg.sender];</span><br><span class="line">    if (amount &gt; 0) &#123;</span><br><span class="line">      // It is important to set this to zero because the recipient</span><br><span class="line">      // can call this function again as part of the receiving call</span><br><span class="line">      // before `send` returns.</span><br><span class="line">      pendingReturns[msg.sender] = 0;</span><br><span class="line"></span><br><span class="line">      if (!payable(msg.sender).send(amount)) &#123;</span><br><span class="line">        // No need to call throw here, just reset the amount owing</span><br><span class="line">        pendingReturns[msg.sender] = amount;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  // 结束拍卖，发送最高出价</span><br><span class="line">  function auctionEnd() public &#123;</span><br><span class="line">    // 1. Conditions</span><br><span class="line">    require(block.timestamp &gt;= auctionEndTime, &quot;Auction not yet ended.&quot;);</span><br><span class="line">    require(!ended, &quot;auctionEnd has already been called.&quot;);</span><br><span class="line">    // 2. Effects</span><br><span class="line">    ended = true;</span><br><span class="line">    emit AuctionEnded(highestBidder, highestBid);</span><br><span class="line">    // 3. Interaction</span><br><span class="line">    beneficiary.transfer(highestBid);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是一段Solidity代码，这段代码完成了一个竞拍的功能。这段代码部署后，网络内的任何人调用这个智能合约内的<code>function bid() public payable</code>函数参与竞价。当然，竞拍有一个最后期限，参与竞拍的人需要在竞拍结束前参与竞价。参与竞拍则需要向这个合约账户内不断转账，例如第一我出价30个以太币，则我需要给合约账户转账30个以太币，如果接着我想加价到50个以太币，则我需要再往合约账户内转账20个以太币。竞拍结束后，竞价最高的人获得奖品，而其他竞拍人的以太币原路返还。接下来我们将逐段拆解以上代码，来学习Solidity。</p>
<p>整个智能合约的第一句指定了Solidity的版本，在这里使用的Solidity语言的版本是0.8.0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br></pre></td></tr></table></figure>
<p>接下来，我们定义了一个合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract SimpleAuction &#123;</span><br><span class="line">  //...略</span><br><span class="line">  // 参数为拍卖时间 _biddingTime 和受益人地址 _beneficiary 的构造函数</span><br><span class="line">  constructor(</span><br><span class="line">    uint _biddingTime,</span><br><span class="line">    address payable _beneficiary</span><br><span class="line">  ) &#123;</span><br><span class="line">    beneficiary = _beneficiary;</span><br><span class="line">    auctionEndTime = block.timestamp + _biddingTime;</span><br><span class="line">  &#125;</span><br><span class="line">  //...略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Solidity中和合约于JavaScript中的Class类似，用<code>contract</code>关键字创建。每个合约都会有一个构造器函数，其固定名称为<code>constructor</code>。构造函数只会在合约被创建的时候调用一次。你可能注意到了，在这段代码中，我们在获取当前时间时使用的时<code>block.timestamp</code>，即包含当前交易这个区块的时间，而不是其他编程语言中常见的操作系统当前时间。这是因为智能合约的执行结果必须是稳定的，这意味着相同的输入和函数，在不同电脑上的执行结果必须是相同的。因此我们将智能合约放在EVM虚拟机上运行，屏蔽了操作系统差异带来的差异。即便是这样，我们在编程语言设计中，仍需要一些特殊的设计来保证执行结果的一致性。在Solidity中，我们不能像其他编程语言那样访问系统的信息（例如系统当前时间，操作系统），因为每个操作系统的信息可能是不一样的。但是Solidity也为我们提供了一些确定的可以访问的信息，例如关于区块的信息：</p>
<table>
<thead>
<tr>
<th><code>block.blockhash(uint blockNumber) returns (bytes32)</code></th>
<th>查询给定区块信息，仅对最近256个区块有效，且不包括当前区块</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>block.coinbase (address)</code></td>
<td>挖出当前区块的矿工地址</td>
</tr>
<tr>
<td><code>block.difficult (uint)</code></td>
<td>当前区块难度</td>
</tr>
<tr>
<td><code>block.gaslimit (uint)</code></td>
<td>当前区块gas限额</td>
</tr>
<tr>
<td><code>block.number (uint)</code></td>
<td>当前区块号</td>
</tr>
<tr>
<td><code>block.timestamp (uint)</code></td>
<td>当前区块时间戳， Unix时间戳</td>
</tr>
</tbody>
</table>
<p>我们还可以访问一些关于关于智能合约调用的一些信息，这些也是确定的：</p>
<table>
<thead>
<tr>
<th><code>msg.data (bytes)</code></th>
<th>这是调用数据的完整副本。在智能合约调用过程中，所有传递的参数都会被编码成字节数据，并包含在msg.data中</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>msg.gas (uint)</code></td>
<td>这是当前剩余的gas。每次调用函数时，都会消耗一定量的gas，msg.gas代表当前函数调用还剩下多少gas。</td>
</tr>
<tr>
<td><code>msg.sender (address)</code></td>
<td>这是消息的发送者的地址。在函数调用过程中，这个地址表示发起调用的账户或合约地址。</td>
</tr>
<tr>
<td><code>msg.sig (bytes4)</code></td>
<td>这是函数签名的前4个字节。这4个字节是由函数名称和参数类型编码生成的哈希值的前4字节。</td>
</tr>
<tr>
<td><code>msg.value (uint)</code></td>
<td>这是随消息一起发送的wei数量。</td>
</tr>
<tr>
<td><code>now (uint)</code></td>
<td>这是当前区块的时间戳，即当前区块的时间戳。它是一个uint类型的数据，等同于block.timestamp。</td>
</tr>
<tr>
<td><code>tx.gasprice (uint)</code></td>
<td>这是交易的gas价格。gas价格是发送者愿意为每单位gas支付的价格，用于激励矿工将交易打包进区块。</td>
</tr>
<tr>
<td><code>tx.origin (address)</code></td>
<td>这是交易发起者的地址，即最原始的调用者。在合约调用链中，tx.origin表示最早发起调用的账户或合约地址。</td>
</tr>
</tbody>
</table>
<p>接着在代码中，我们定义了合约的一些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 拍卖的参数。时间单位是秒。</span><br><span class="line">address payable public beneficiary;</span><br><span class="line">uint public auctionEndTime;</span><br><span class="line">// 当前状态</span><br><span class="line">address public highestBidder;</span><br><span class="line">uint public highestBid;</span><br><span class="line">// 可以取回的以前的出价</span><br><span class="line">mapping(address =&gt; uint) pendingReturns;</span><br><span class="line">// 拍卖结束的标志</span><br><span class="line">bool ended;</span><br></pre></td></tr></table></figure>
<p>在这里，我们定义了一些合约内需要使用到的属性，这里<code>address</code>是Solidity中的特殊类型，记录了一个账户地址，这个账户地址可以是EOA账户，也可以是另一个合约账户。这里<code>uint</code>代表了一个无符号整型，Solidity中默认的大小为256位。<code>mapping(address =&gt; uint)</code>代表了一个哈希表，在这里可以看出是一个账户地址<code>address</code>到一个账户余额（这里是<code>uint</code>）的映射。Solidity中的哈希表不支持遍历，如果需要遍历哈希表，则需要额外记录一份包含所有键的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 拍卖的事件</span><br><span class="line">event HighestBidIncreased(address bidder, uint amount);</span><br><span class="line">event AuctionEnded(address winner, uint amount);</span><br></pre></td></tr></table></figure>
<p>接着我们定义了一些时间，这些时间需要使用<code>emit</code>关键字触发。事件触发后会在区块链上记录下相应的日志，常见的事件有：记录代币或者以太币的转移、记录代币合约中批准某个地址可以代表另一个地址花费一定数量的代币、记录合约所有权的转移、记录存取款操作等，这些日志会用于生成<code>Bloom Filter</code>帮助外部软件快速查询发生过的事件。例如我们可以创建一个Web网站实时观察这个智能合约的竞价情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 出价函数</span><br><span class="line">  function bid() public payable &#123;</span><br><span class="line">    // 不允许拍卖结束后出价</span><br><span class="line">    require(</span><br><span class="line">      block.timestamp &lt;= auctionEndTime,</span><br><span class="line">      &quot;Auction already ended.&quot;</span><br><span class="line">    );</span><br><span class="line">    // 如果出价不够高，返还出价</span><br><span class="line">    require(</span><br><span class="line">      msg.value &gt; highestBid,</span><br><span class="line">      &quot;There already is a higher bid.&quot;</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    if (highestBid != 0) &#123;</span><br><span class="line">      // 返还以前的最高出价</span><br><span class="line">      pendingReturns[highestBidder] += highestBid;</span><br><span class="line">    &#125;</span><br><span class="line">    highestBidder = msg.sender;</span><br><span class="line">    highestBid = msg.value;</span><br><span class="line">    emit HighestBidIncreased(msg.sender, msg.value);</span><br><span class="line">  &#125;</span><br><span class="line">  // 取回出价</span><br><span class="line">  function withdraw() public returns (bool) &#123;</span><br><span class="line">    uint amount = pendingReturns[msg.sender];</span><br><span class="line">    if (amount &gt; 0) &#123;</span><br><span class="line">      // It is important to set this to zero because the recipient</span><br><span class="line">      // can call this function again as part of the receiving call</span><br><span class="line">      // before `send` returns.</span><br><span class="line">      pendingReturns[msg.sender] = 0;</span><br><span class="line"></span><br><span class="line">      if (!payable(msg.sender).send(amount)) &#123;</span><br><span class="line">        // No need to call throw here, just reset the amount owing</span><br><span class="line">        pendingReturns[msg.sender] = amount;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  // 结束拍卖，发送最高出价</span><br><span class="line">  function auctionEnd() public &#123;</span><br><span class="line">    // 1. Conditions</span><br><span class="line">    require(block.timestamp &gt;= auctionEndTime, &quot;Auction not yet ended.&quot;);</span><br><span class="line">    require(!ended, &quot;auctionEnd has already been called.&quot;);</span><br><span class="line">    // 2. Effects</span><br><span class="line">    ended = true;</span><br><span class="line">    emit AuctionEnded(highestBidder, highestBid);</span><br><span class="line">    // 3. Interaction</span><br><span class="line">    beneficiary.transfer(highestBid);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们定义了这个合约的主要内容，Solidity中使用<code>function</code>关键字声明函数。<code>public</code>是访问控制，表明这个函数谁可以调用，<code>returns</code>表明了这个函数返回什么参数。<code>Payable</code>意味着这个函数接受转账，这是Solidity中规定，所有接受转账的函数都需要声明<code>payable</code>。在编写智能合约的时候，我们可以使用<code>require</code>或者<code>assert</code>关键字审查条件，抛出错误：</p>
<table>
<thead>
<tr>
<th><code>assert(bool condition)</code></th>
<th>如果条件不满足就抛出一个内部错误</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>require(bool condition)</code></td>
<td>如果条件不满足就抛出一个用于输入或者外部组件组件引起的错误</td>
</tr>
<tr>
<td><code>revert()</code></td>
<td>直接终止运行并且回滚状态变动</td>
</tr>
</tbody>
</table>
<p>当其他账户想要调用它这个合约时，需要发起一笔对这个合约账户地址的交易，并且将需要调用的函数以及调用函数的参数（如果有）在data域中说明。在所有函数中，有一个特殊的函数，<code>fallback()</code>函数（在这个例子中没有）。这个函数与<code>constructor()</code>函数类似，名字是固定的并且没有参数，没有返回值。当其他账户调用合约时出现调用函数不存在，或者直接向该地址转账而不指明调用函数等错误调用时，就会默认调用这个函数。<code>fallback()</code>函数也可以标为<code>payable</code>，如果需要处理直接转账这类错误，则需要将<code>fallback()</code>函数标记为payable。如果没有标记为payable的<code>fallback()</code>函数被转账交易调用时，则会发生错误然后回滚。</p>
<p>EOA账户在调用合约的时候需要指明转账费用<code>value</code>，<code>gas price</code>单位gas的费用（即一单位gas换算为多少以太币），<code>gas limit</code>交易最多使用的gas费用。以太坊中单位gas的费用并非是一成不变的，其价格会随着网络的拥堵情况而上下浮动——当网络较为拥堵的时候，单位gas就比较贵，当网络不拥堵时，则比较便宜。除了EOA账户可以调用智能合约外，智能合约也可以调用智能合约。智能合约可以在代码中调用其他智能合约，有这样几种调用方式：</p>
<table>
<thead>
<tr>
<th>通过构造函数将地址转换成实例，在实例上调用函数</th>
<th>被调用函数报错，调用函数也会被回滚</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>address.call(要调用的函数的签名，函数的参数)</code></td>
<td>执行出错不会引发回滚，而是返回一个false，如果执行成功，则返回true；可以通过.gas()和.value()调整提供的gas数量或者提供ETH的数量</td>
</tr>
<tr>
<td><code>address.delegatecall()</code></td>
<td>与call相同，但是不能使用value；不切换上下文，使用当前合约的属性（存储，余额），主要用于使用存储在另外一个合约中的库lib代码</td>
</tr>
</tbody>
</table>
<h3 id="针对智能合约的攻击">针对智能合约的攻击</h3>
<p>智能合约一旦部署到区块链上，则再也不能更改。如果代码中有逻辑漏洞，会对合约的参与者造成重大损失。所以智能合约的代码在部署之前，都会先部署在测试网址以测试其安全性。同时，在编写Solidity代码时，开发人员需要遵守代码开发规范以避免常规漏洞的出现，例如在转账时，需要先判断条件，再改变条件，最后再和其他合约交互。这样的处理是为了防范重入攻击。</p>
<h4 id="重入攻击">重入攻击</h4>
<p>重入攻击是以太坊中最今典的案例，2016年黑客使用重入攻击从TheDAO合约中盗取了价值约1亿5000万美元的以太币，其总量为整个以太坊中以太币数量的二十分之一。由于其事件影响重大，以太坊不得不强制回滚链上数据，从而导致以太坊社区分裂。后来人称这个事件为TheDAO。以下是一段经典的重入攻击的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 这是被攻击和合约的代码</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Vulnerable &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint _amount) public &#123;</span><br><span class="line">        require(balances[msg.sender] &gt;= _amount, &quot;Insufficient balance&quot;);</span><br><span class="line">        // 1. 合约调用之前未更新用户余额</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line">        // 2. 在转账后才更新用户余额</span><br><span class="line">        balances[msg.sender] -= _amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 这是攻击者写的攻击代码</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attacker &#123;</span><br><span class="line">    Vulnerable vulnerableContract;</span><br><span class="line">    bool public attackMode;</span><br><span class="line">    uint public amountToWithdraw = 1 ether;</span><br><span class="line"></span><br><span class="line">    constructor(address _vulnerableAddress) &#123;</span><br><span class="line">        vulnerableContract = Vulnerable(_vulnerableAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        attackMode = true;</span><br><span class="line">        // 3. 攻击者向漏洞合约存入资金</span><br><span class="line">        vulnerableContract.deposit&#123;value: amountToWithdraw&#125;();</span><br><span class="line">        // 4. 攻击者立即调用漏洞合约的提款函数</span><br><span class="line">        vulnerableContract.withdraw(amountToWithdraw);</span><br><span class="line">        attackMode = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        // 5. 回退函数在攻击模式开启时被调用</span><br><span class="line">        if (attackMode) &#123;</span><br><span class="line">            vulnerableContract.withdraw(amountToWithdraw);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getBalance() public view returns (uint) &#123;</span><br><span class="line">        return address(this).balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，被攻击的合约内的<code>withdraw()</code>函数没有在转账之前就将攻击者账户清零，因此给了攻击者可乘之机。攻击者可以撰写一段恶意代码部署到网络中。这段恶意代码中，攻击者向被攻击合约存入了一定数量的以太币，又立马提取出来。提取时，攻击者的合约调用了被攻击合约的<code>withdraw()</code>函数，但是由于攻击者是使用智能合约调用被攻击智能合约的，因此被攻击合约会向攻击合约发起一笔交易。 在 Solidity 中，当一个合约接收到以太币时，如果没有显式定义一个接收以太币的函数（如 <code>receive()</code> 函数），或者如果没有匹配调用的函数签名（即没有匹配合约函数），那么合约会尝试执行它的回退函数（fallback 函数）。因此攻击者编写的合约中的<code>fallback()</code>函数会执行。而攻击者的<code>fallback()</code>函数中，再一次向被攻击合约发起了提取请求，于是被攻击合约会再一次向攻击合约转账。被攻击合约会一直向攻击合约转账，知道被攻击合约内的余额被清空。</p>
<p>为了预防这种攻击，我们在编写智能合约时可以遵守以下几点规则：</p>
<ul>
<li><strong>更新状态优先原则</strong>: 在转账或其他状态更改之前，应首先更新相关账户的状态。</li>
<li><strong>使用最新的 Solidity 版本</strong>: Solidity 不断更新以修复安全漏洞，使用最新版本可以减少受到已知攻击方式的风险。</li>
<li><strong>安全的资金转移模式</strong>: 使用 <code>send()</code> 或 <code>transfer()</code> 函数进行资金转移，这些函数在转账失败时会抛出异常，可以避免部分重入攻击。</li>
</ul>
<h4 id="溢出攻击">溢出攻击</h4>
<p>Solidity中的整数一般都是256位的，如果超过256位，整数就会发生溢出。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract OverflowExample &#123;</span><br><span class="line">    uint public balance = 100;</span><br><span class="line"></span><br><span class="line">    function add(uint _addend) public &#123;</span><br><span class="line">        balance += _addend;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function sub(uint _subtrahend) public &#123;</span><br><span class="line">        balance -= _subtrahend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如在这段代码内，如果调用<code>sub()</code>函数给余额减去一个超过100的数字，余额就会溢出，变成一个很大的数字。因此，在Solidity中进行重要数据计算时，Solidity建议我们遵循以下几点建议：</p>
<ul>
<li><strong>安全的数学库</strong>：使用安全的数学库来进行整数操作，如 <code>SafeMath</code> 库，可以有效避免整数溢出的风险。</li>
<li><strong>适当的输入验证</strong>：在接收参数时进行适当的范围验证和检查，确保参数在合理范围内，避免意外的溢出情况。</li>
<li><strong>使用适当的数据类型</strong>：根据业务逻辑选择合适的数据类型，避免不必要的数据类型溢出问题。</li>
</ul>
<h2 id="执行层">执行层</h2>
<h3 id="evm">EVM</h3>
<p><img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/1721359118165-91448caf-3b26-4d61-b4c7-56fdbd3697c8.png" alt></p>
<p>图中各个部分的内容对应解释如下：</p>
<ul>
<li><strong>Contract</strong>：智能合约的字节码存储在这里，执行过程中会从中提取指令。</li>
<li><strong>PC（Program Counter）</strong>：程序计数器，指示当前要执行的指令在字节码中的位置。</li>
<li><strong>OpCode</strong>：操作码，是从智能合约字节码中提取出来的具体指令。</li>
<li><strong>Gas</strong>：每执行一步操作都会消耗一定的Gas，Gas用于防止恶意代码无限循环消耗系统资源。</li>
<li><strong>operation</strong>：每个操作码对应的具体操作，由JumpTable（跳转表）中的具体实现来执行。</li>
<li><strong>JumpTable</strong>：存储所有可能的操作及其实现，共256种操作。</li>
<li><strong>Stack（堆栈）</strong>：用于存储临时数据，最大深度为1024。</li>
<li><strong>Memory（内存）</strong>：临时数据存储区，在合约执行期间可读写。</li>
<li><strong>StateDB（状态数据库）</strong>：持久化存储智能合约的状态变化。</li>
</ul>
<p>整个EVM的运行过程就是不断从合约字节码中获取指令，译码成操作码，然后根据操作码从JumpTable中找到对应的操作执行，并通过堆栈和内存来存储和获取临时数据，最后更新状态数据库中的合约状态，同时消耗相应的Gas来防止资源滥用。其具体执行步骤如下：</p>
<ol>
<li><strong>获取指令</strong>：EVM从程序计数器（PC）处获取当前要执行的指令。</li>
<li><strong>译码</strong>：将获取的指令转换为机器可以理解的操作码（OpCode）。</li>
<li><strong>执行</strong>：根据OpCode指示执行相应的操作。</li>
<li><strong>获取指令返回值</strong>：执行完成后，从堆栈（Stack）或内存（Memory）中获取操作结果。</li>
<li><strong>异常处理及指令跳转</strong>：如果在执行过程中遇到异常，会跳转到相应的异常处理逻辑；否则，继续执行下一条指令。</li>
<li><strong>结果</strong>：最终，所有指令执行完毕，得到最终结果。</li>
</ol>
<h2 id="账本层">账本层</h2>
<p>以太坊采用基于账户的交易模式，每个节点都要储存一份账本的副本。为了保持每个节点中账本状态一致，以太坊需要在账本状态上达成共识。直接将整个账本存储在区块内是不现实的，这个账本包含了全球所有账户的信息（其实是有余额账户的信息）。因此我们选择将所有账户构建成一个类似默克尔树的数据结构，而账本的状态使用储存在区块头内的一个哈希值（类似默克尔树根）表示。矿工可以通过这个字段判断自己本地的账户的副本是否域网络内的一致。我们把这个字段叫做默克尔帕特里夏树树根（Merkel Patricia Tree Root, MPT Root）。MPT是一个保存了所有交易哈希值的默克尔字典树，但是于比特币中默克尔树不同的是，这个默克尔字典树还储存了默克尔根到默克尔节点的路径，而且其路径是由该账户的地址决定的。</p>
<p>直接使用比特币中的默克尔树来代表矿工本地账本的副本将会面临种种问题：第一个问题就是不同人构建默克尔树顺序不一样，因此计算出来的默克尔根也不一样。第二个就是效率低下。如果我们对默克尔树进行排序，从而让每个人构建默克尔树的顺序一致，那么会导致查找和插入的效率十分低下。比特币中，一个默克尔树只包含几千个交易，而以太坊中储存的是全球所有账户的状态，有数千万个账户。这样构建出来的默克尔树十分庞大，如果我们希望插入一个新的账户，我们需要重新计算几千万次哈希。那我们可以直接使用哈希表存储账户的状态吗？直接使用哈希表存储账户的状态会让全节点无法提供默克尔证明，从而导致轻节点的消失。那我们可以把哈希表的内容组织成一个默克尔树吗？这样仍然会导致默克尔树更新和插入的效率低下——即便大多数账户是不变的，每次某一个账户的改变我们都要重新计算几千万次哈希。</p>
<p>在以太坊中，我们使用默克尔字典树来储存账户的状态。默克尔树是一种既查找、插入、和更新方便，又能提供默克尔证明的数据结构。以下是默克尔树的组成：</p>
<h3 id="mpt的构成">MPT的构成</h3>
<p>MPT是三个数据结构的结合，分别是默克尔树，压缩字典树，字典树。字典树是一个存储键值对的树，在这个数据结构内，键是按照相同的前缀构成一个节点的，不同的后缀构成一个分叉而构成一颗树的。例如：apple, app, bat, ball, cat三个单词可以构成如下的字典树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">          root</span><br><span class="line">         /  |  \</span><br><span class="line">        a   b   c</span><br><span class="line">       /    |    \</span><br><span class="line">      p     a     a</span><br><span class="line">     / \    |     |</span><br><span class="line">    p   l   t     t</span><br><span class="line">   /    |   |     |</span><br><span class="line">  l     e   l     t</span><br><span class="line"> /      |   |</span><br><span class="line">e       l   l</span><br><span class="line">        |</span><br><span class="line">        e</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上图中我们可以观察到，只有分叉的节点是有效的，大量竖直的节点造成了空间的浪费。因此，我们可以将相同前缀的节点压缩，构成一个压缩字典树，这样可以大大加速查询的效率。其图示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     root</span><br><span class="line">    / |  \</span><br><span class="line">  app bat  cat</span><br><span class="line">  /   |</span><br><span class="line">le   ll</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以太坊采用Modified Merkel Patricia Tree储存账户的信息， MPT将默克尔树和压缩树结合，其保存了账户地址的哈希到账户内信息的映射。而以太坊在MPT之上，修改了一点，将节点分为了Branch Node，Extension Node，和Leaf Node三种节点构成Modified MPT。其图示如下：</p>
<p><img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/1720504074490-44f53eff-39c0-4844-b4f9-974327e951d4.png" alt></p>
<p>在MPT中，我们将所有节点分为三个类别，分别是扩展节点（Extension Node）、分支节点（Branch Node）、和叶节点（Leaf Node）。扩展节点用于储存压缩字典树中共同前缀，在这里，地址哈希前缀相同的节点会被分到同一个分支。</p>
<ul>
<li>一个扩展节点具体包括一个节点前缀 0，子节点共同前缀（例如上图中的a7），和下一个分支结点的哈希值。一个扩展结点一定对应了一个分支节点。</li>
<li>分支节点包含了0~F 16个16进制的数字（这里每一个数字我们叫做一个nibble，即4个bit，<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/6c0f61488120244c034ca66647922e0f.svg" alt="image">个字节），代表不同子节点的前缀，和一个value字段，用于储存账户信息。分支节点内自己的哈希值由节点内的所有哈希值，使用RLP（Recursive Length Prefix）序列化后拼接起来（包括value字段，空的哈希值将会使用空值代替，例如“”空字符串或者None），再计算哈希得来。例如上图中的从上到下第一个蓝色的分支节点，其哈希值计算如下：</li>
</ul>
<p><img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/c816d4cbdf949f1efa8a95759b57290f.svg" alt="image"></p>
<ul>
<li>最后是叶节点，叶节点内保存了账户信息。例如账户余额，账户<code>nonce</code>等信息。</li>
</ul>
<p>我们对整个MPT的根节点做KECCAK256哈希运算，即KECCAK256（0 || a7 || 下一个节点哈希值），就能得到整个MPT的根哈希值，我们将这个根哈希值打包入区块头，其他人就能快速验证自己本地账本的状态和网络中其他矿工的账本状态是否一致。以下是go-ethereum中，区块头的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header represents a block header in the Ethereum blockchain.</span></span><br><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">    ParentHash  common.Hash    <span class="string">`json:&quot;parentHash&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">    UncleHash   common.Hash    <span class="string">`json:&quot;sha3Uncles&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">    Coinbase    common.Address <span class="string">`json:&quot;miner&quot;`</span></span><br><span class="line">    Root        common.Hash    <span class="string">`json:&quot;stateRoot&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">    TxHash      common.Hash    <span class="string">`json:&quot;transactionsRoot&quot; gencodec:&quot;required&quot;`</span></span><br><span class="line">    ReceiptHash common.Hash    <span class="string">`json:&quot;receiptsRoot&quot;     gencodec:&quot;required&quot;`</span></span><br><span class="line">    Bloom       Bloom          <span class="string">`json:&quot;logsBloom&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">    Difficulty  *big.Int       <span class="string">`json:&quot;difficulty&quot;       gencodec:&quot;required&quot;`</span></span><br><span class="line">    Number      *big.Int       <span class="string">`json:&quot;number&quot;           gencodec:&quot;required&quot;`</span></span><br><span class="line">    GasLimit    <span class="type">uint64</span>         <span class="string">`json:&quot;gasLimit&quot;         gencodec:&quot;required&quot;`</span></span><br><span class="line">    GasUsed     <span class="type">uint64</span>         <span class="string">`json:&quot;gasUsed&quot;          gencodec:&quot;required&quot;`</span></span><br><span class="line">    Time        <span class="type">uint64</span>         <span class="string">`json:&quot;timestamp&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">    Extra       []<span class="type">byte</span>         <span class="string">`json:&quot;extraData&quot;        gencodec:&quot;required&quot;`</span></span><br><span class="line">    MixDigest   common.Hash    <span class="string">`json:&quot;mixHash&quot;`</span></span><br><span class="line">    Nonce       BlockNonce     <span class="string">`json:&quot;nonce&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BaseFee was added by EIP-1559 and is ignored in legacy headers.</span></span><br><span class="line">    BaseFee *big.Int <span class="string">`json:&quot;baseFeePerGas&quot; rlp:&quot;optional&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// WithdrawalsHash was added by EIP-4895 and is ignored in legacy headers.</span></span><br><span class="line">    WithdrawalsHash *common.Hash <span class="string">`json:&quot;withdrawalsRoot&quot; rlp:&quot;optional&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BlobGasUsed was added by EIP-4844 and is ignored in legacy headers.</span></span><br><span class="line">    BlobGasUsed *<span class="type">uint64</span> <span class="string">`json:&quot;blobGasUsed&quot; rlp:&quot;optional&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExcessBlobGas was added by EIP-4844 and is ignored in legacy headers.</span></span><br><span class="line">    ExcessBlobGas *<span class="type">uint64</span> <span class="string">`json:&quot;excessBlobGas&quot; rlp:&quot;optional&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ParentBeaconRoot was added by EIP-4788 and is ignored in legacy headers.</span></span><br><span class="line">    ParentBeaconRoot *common.Hash <span class="string">`json:&quot;parentBeaconBlockRoot&quot; rlp:&quot;optional&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">b不d</span><br></pre></td></tr></table></figure>
<p>其中<code>Root</code>字段就是状态数的树根。以下是以太坊中区块的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">    header       *Header</span><br><span class="line">    uncles       []*Header</span><br><span class="line">    transactions Transactions</span><br><span class="line">    withdrawals  Withdrawals</span><br><span class="line"></span><br><span class="line">    <span class="comment">// caches</span></span><br><span class="line">    hash atomic.Pointer[common.Hash]</span><br><span class="line">    size atomic.Uint64</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These fields are used by package eth to track</span></span><br><span class="line">    <span class="comment">// inter-peer block relay.</span></span><br><span class="line">    ReceivedAt   time.Time</span><br><span class="line">    ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以太坊的一个区块中，包含了多个交易，以及一个区块头和多个叔父区块头。其中，每笔交易内包含了转账金额，转账目标账户地址，以及附加的数据</p>
<p>以太坊中经常出现分叉，为了鼓励分叉尽快合并到最长链上，以太坊规定被主链包含的分叉区块也能得到奖励。被包含的区块将以叔父区块的形式记录在主链上。其具体规则会在GHOST协议中讲到。<code>withdrawals</code>字段则是根区块的奖励有关。以下是网络中传输的区块的信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> extblock <span class="keyword">struct</span> &#123;</span><br><span class="line">    Header      *Header</span><br><span class="line">    Txs         []*Transaction</span><br><span class="line">    Uncles      []*Header</span><br><span class="line">    Withdrawals []*Withdrawal <span class="string">`rlp:&quot;optional&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="状态树">状态树</h3>
<p>在以太坊中，我们把网络中所有的账户结合起来，构建出一棵MPT树，我们把构建出来的树叫做状态树，意思是储存网络中账本状态的树。MPT树是以键值对的形式保存数据的——在状态树中，键（key）是账户的地址，值（value）是账户的状态，即账户的余额，交易次数，代码（合约账户），存储（合约账户）。通过MPT构建出来的状态树，不仅可以防伪，还能方便查找，更新和插入：</p>
<ul>
<li>如果有人想要篡改账户余额，那么MPT的根哈希值就会改变。因此通过哈希值，我们能验证MPT中内容的真实性。</li>
<li>我们还能快速查找账户余额，例如我们想要查询上图中MPT内账户地址为a711355的余额，我们只需要找到a7节点，接着找字符1，接着1355，然后我们就能找到该账户对应的余额45 ETH。</li>
<li>如果需要更新账户内容或者插入新的账户，我们只需要重新计算修改账户的哈希值以及修改的账户之上节点的哈希值，就可以更新整颗状态树。并且我们不用担心构建顺序的不同，会导致生成不同的状态树。</li>
</ul>
<p>在实际实现中，需要修改状态树的内容时，矿工会在原有的分支旁临时分叉出来一个新的分支来记录新的账户信息。因为以太坊中的出块速度很快，出块时间在15秒上下浮动。因此在链会经常分叉，矿工需要经常回滚账本的状态。账本的状态的改变跟智能合约的执行过程相关，我们很难根据通过交易内容和现在账本状态回推到上个账本状态，因此矿工需要时时保存账本的状态，回滚的时候只需要切换回原先的状态就好。</p>
<p>以太坊中，交易会引起状态树的改变，因此我们说以太坊是一个由交易驱动的状态机。但是为了达成一致，状态的转移必须是确定的，即相同的初始状态在经历相同的交易后，必须能得到相同的结果状态。所以在EVM中，我们的代码不能使用真随机数，也不能访问系统的信息（因为不同操作系统信息会带来差异）。</p>
<h3 id="交易树和收据树">交易树和收据树</h3>
<p>交易树和收据树分别对应者区块体中的交易和由交易产生的收据，者两棵树也是MPT树。其根哈希值也被记录在区块头中，分别对应了上面区块头代码中的<code>TxHash</code>和<code>ReceiptHash</code>字段。MPT树是以键值对的形式记录数据的。在交易树和收据树中，键（key）对应着交易（或者是收据）在区块中的序数，例如区块内的第几个交易，值对应着交易（或者是收据）内的具体内容。用MPT记录交易和收据，不仅可以让我们给轻节点提供默克尔证明（轻节点可以通过默克尔证明快速验证交易和收据），还可以方便我们快速查找交易和收据。从上面区块头的代码中可以看出，每个区块头都包含了一个<code>Bloom</code>字段。通过以太坊区块的头部当中<code>Bloom</code>字段，我们可以实现快速条件查询区块内包含的交易和收据中的内容。例如“查找所有区块中跟XXX账户相关的交易”。这种快速查找的机制是通过布隆过滤器（Bloom Filter）实现的，下面我将介绍以下布隆过滤器的具体原理。</p>
<h2 id="共识层">共识层</h2>
<h3 id="ghost协议">GHOST协议</h3>
<p><img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/1721207538366-c8194fcd-e98a-4826-a06d-12c0f7c5c428.png" alt></p>
<p>在GHOST协议中规定，如果矿工愿意在新挖出来的区块内包含叔块，每包含一个不同的叔块可以多拿挖矿奖励的<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/077038f722decabccda8020e8c40cf3f.svg" alt="image">。以太坊中的挖矿奖励是固定的，在2016年以前，每个新区块的奖励固定为5个以太币ETH，2016年以太坊大幅度降低了挖矿难度，为了公平起见，之后以太坊中每个新区块的奖励被降低为3个以太币。在这里，额外的以太币奖励是固定的。同时挖出叔块的矿工，可以得到常规挖矿奖<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/95791e9ff90cbc46c649edceaa9a9b0a.svg" alt="image">。为了控制网络内新币的发行，GHOST协议规定每个新区块最多只能包含两个叔块。</p>
<p>如果没有这样的奖励规则，当矿工发现自己所在的分链落后，会更倾向于在自己原本的链上继续挖矿，而不是切换到最长链上。因为如果一旦有机会赶上最长链，自己之前所有努力都能兑现，而一旦切换到最长链上，就要放弃所有可能的收益。这样往往会让两条链上的矿工在连续挖好几个区块后，才发现赶上另一条链的机会微乎其微。这样这个分链上的交易都要回滚，而且需要连续回滚好几个区块，这样不利于以太坊的生态。给与叔块挖矿者奖励可以鼓励挖矿者尽快回到主链，减少网络内的分叉。同时，如果没有GHOST规则，网络内的规则会鼓励矿池的发展。新区快在矿池内传播的更快，其发布的区块更有可能成为最长链，从而鼓励矿工加入矿池。集中化的大型矿池是以太坊团推不想看到的，给与叔块奖励可以极大的缓解这个问题。但这样的协议仍然会引起问题，相互竞争的矿池可以故意不包含对方的区块，这样自己的损失只有<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/077038f722decabccda8020e8c40cf3f.svg" alt="image">而对方的损失则有<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/95791e9ff90cbc46c649edceaa9a9b0a.svg" alt="image">。同时，如果同时有3个叔块出现，让有一个叔块不会被包含入主链，其中的矿工则还是倾向于在自己区块后挖矿，而不是加入主链。因此以太坊中改进了GHOST协议。</p>
<h3 id="以太坊ghost协议">以太坊GHOST协议</h3>
<p>在以太坊中，前六个区块的平级叔父区块都能获得奖励，并且奖励随着代数减少。例如当前上一个区块为父区块，与其平级同父的叔块能获得<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/95791e9ff90cbc46c649edceaa9a9b0a.svg" alt="image">的奖励，再往前一级的叔块则只能得到<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/b253f786fac7854aba7cb5d076f90a77.svg" alt="image">…一直到往前倒数第六级，其级叔块则只能得到<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/18bf7848f9e9337db34d5c2915b32e1f.svg" alt="image">的奖励，再往前则没有奖励了。包含叔块的奖励仍是<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/077038f722decabccda8020e8c40cf3f.svg" alt="image">，最多只能包含两个叔块。越来越少的奖励费鼓励叔块尽快和并入主网，而且这种形式也能防止矿工之间恶意竞争。</p>
<p><img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/1721210926813-df8a5f74-bb1b-4d70-91e5-667f0bc875f4.png" alt></p>
<p>被包含的叔块虽然能拿到一定的区块奖励，但是叔块内交易的gas费矿工是得不到的。同时包含叔块的新区块是不验证叔块的交易的，只有叔块的头部被包含在新区块中。那我们能奖励叔块后面其他的分支区块吗？奖励叔块后面其他分支区块会降低分叉攻击成本，因此，只有每条分链的第一个区块能收到奖励。</p>
<h3 id="以太坊中的pow算法">以太坊中的PoW算法</h3>
<p>加密货币在发展的过程中，挖矿设备逐渐专业化，集中化。在比特币网络内，矿工们最初用的挖矿设备为CPU，这也是中本聪构想中的挖矿设备。后来随着GPU的兴起，人们开始尝试使用GPU挖矿。一块GPU挖矿的效率是CPU的好几千倍。由于比特币中的挖矿收益是由其算力在网络中的占比决定的，随着越来越多的人开始迁移到GPU上挖矿，CPU挖矿的方式逐渐得不到任何收益。随着比特币市值的提高，又有人开始定制芯片挖矿，我们把这种定制芯片的挖矿机叫做ASIC，一个ASIC矿机的挖矿效率是GPU的好几千倍。现在比特币网络中，即便是使用最先进的显卡，也几乎得不到任何收益了。并且随着ASIC芯片的大规模应用，挖矿开始出现中心化的势头。ASIC芯片昂贵且异能用于挖矿，只有专业化的矿工才会购买，并且一次购买就是大量的购买然后组建矿场。可以预料到，未来随着越来越多的人大规模组建矿场，小规模的矿池会越来越得不到收益，最后整个网络中就会剩几个大矿池来负责挖矿。</p>
<p>对于这样的趋势社区中有人认为这样会强化比特币网络的安全性，因为一旦有人想恶意破坏，就需要购买大量昂贵的设备，且其在破坏后得不到任何收益。也有人认为这样违反中本聪最初的构想，中本聪最初在比特币白皮书中提到，比特币最理想的情况是“One CPU One Vote”，这样集中化的挖矿违反了最初“去中心化的理念”。以太坊中设计的挖矿算法就完全遵循去中心化的理念，以太坊中的算法是ASIC-Resistant的。即很难开发针对该挖矿算法的专业矿机。</p>
<h3 id="asic-resistant-pow-算法">ASIC-Resistant PoW 算法</h3>
<p>ASIC专业矿机一般有以下特点，一是其在计算能力强，在计算特定算法时能耗很少，算力很高。二是其内存一般很小，因为给ASIC矿机大量配备内存是一件十分昂贵的事情。因此，针对ASIC矿机的缺点，我们可以设计出一种很难用ASIC矿机挖矿的算法，即对内存需求大的挖矿算法。这样对内存需求大的算法，我们一般叫做“Memory-Hard”算法。最早使用“Memory-Hard”算法的加密货币叫做LiteCoin，其使用的挖矿算法的名字叫做SCRYPT。其基本思想是，使用一个固定的很大的数组，在计算哈希算法时，需要按一定规则从数组内取值。数组可以是按一定规则生成的，例如数组内的每一个数字都是上一个数字的哈希值。这样我们就不用再数组内保存所有数字，我们只需要保存奇数位或者偶数位的数字（或者隔n个数字保存一个）。我们使用数组中的数字的时候就可以根据已有的数字计算出来。LiteCoin中使用的就是一个128Kb的数组，其中每一个数字都是上一个数字的哈希值，数组内的第一个数字是一个种子（seed）数字的哈希值。</p>
<p>但是这样设计出来的算法让轻节点验证成为难题。轻节点在验证的时候，也要计算出一个整个数组后，再计算哈希值。因此在设计数组时，往往不能设计的太大。在LiteCoin中，使用128Kb作为其数组大小，这是一个折中的设计。以太坊则采取了另一种算法，以太坊中分为一小一大两个数据集，小的数据集叫cache，大的数据集叫DAG；cache是由上述的方法用种子生成的，而DAG则是由cache生成的；轻节点只需要计算出cache就可以验证交易，而矿工则需要在内存内保存DAG来挖矿。这样既平衡了轻节点验证的需求，也抑制了专用矿机的发展。</p>
<p>以太坊采用的挖矿算法叫做ETHASH，其中小数据集cache有16MB，大的数据集DAG有1Gb大小，并且大小数据集都会随着时间增加，每隔30000个区块增加原始大小的<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/fa824eb29af86a528f6eac3e474d8541.svg" alt="image">，即小数据集增加128Kb，大数据集增加8Mb。这样的设计是为了应对越来越便宜的内存价格。且大小数据集的内容每隔30000个区块就改变一次，以防特定的固件产生。</p>
<p>DAG是通过cache数据集计算出来的，并且DAG中每个数据都想读独立，只依赖于cache中一小部分数据。这让轻节点在验证的时候不需要计算出整个DAG数据集，其只用实时计算出DAG中验证时需要使用的数据。而矿工在挖矿时，需要大量访问DAG数据集，因此矿工在内存中保存一份DAG数据集是更好的选择。</p>
<p>以太坊中，挖矿的难度和比特币一样也是动态调整的，其难度调整公式如下：</p>
<p><img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/1e73f3f64bbd0d51a326e5e94058e6b9.svg" alt="image"></p>
<p>其中，<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/7e07464cbafe296bcbcee67d7c0b1923.svg" alt="image">是本区块难度，由基础部分和难度炸弹相加得到。<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/e9ff6f393a5d45962e9308baa48e95fc.svg" alt="image">是整个网络中挖矿难度的下限，这意味着网络中不能有区块的挖矿难度币<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/e9ff6f393a5d45962e9308baa48e95fc.svg" alt="image">小。<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/7c102e7a7d231bf935f9bc23417779a8.svg" alt="image">是难度炸弹，是以太坊创始人为了以太坊未来逐渐转为权益证明（PoS）而准备的。以太坊在发行初期，就计划未来使用权益证明而不是工作量证明。为了避免在转向权益证明的时候，以太坊中的矿工联合起来抵制权益证明，于是设计了这个难度炸弹。这个难度炸弹使得以太坊中区块在到达一定高度时，其挖矿难度会指数级增长。<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/7c102e7a7d231bf935f9bc23417779a8.svg" alt="image">的计算公式为 <img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/16c85081caeda959680951f3c9695592.svg" alt="image">，其中<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/85e05e066dd94230a4768ce5e17b7462.svg" alt="image">为区块的高度。在2016年，以太坊将实际的转向权益证明的时间向后推迟了三百万个区块，因此，在计算难度时所使用的区块高度比实际区块高度少三百万个区块，即<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/122dee5015352f4b0d30e1cc17362f3c.svg" alt="image">，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">H_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为实际区块高度。</p>
<p><img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/4f28775750d27c08986bb81800e0c48e.svg" alt="image">是挖矿难度的基础调整部分。<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/a83f11b0f2c0f80d3cb11a27094ded8a.svg" alt="image">为父区块难度，每个难度都是在父区块难度上进行调整。<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/90884a9166b3959d75d0b29ace1d3c04.svg" alt="image">用于自适应调节区块难度，维持稳定的出块速度。其中<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/09001ce99dd81834cce178ab5d32d7f6.svg" alt="image">，是调整难度的单位。即调整难度时，是以父块难度的<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/0cec12a8c33f4c6b633539ecfeac7230.svg" alt="image">为单位进行调整的。<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/74ebb7c5a9c473a56f914c4fafcc392f.svg" alt="image">，是调整难度的系数：如果这个系数是负的，意味着网络内难度需要往下调整；是正的话，意味着网络内难度因该往上调整。并且一次性最多往下调整99个难度单位——如果矿工能无限的向下调整难度的话，网络内的难度炸弹将不起作用。这个公式中<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/bf98c0ddcbe9c1e535f767c78c3aa813.svg" alt="image">跟父区块中是否包含uncle区块有关，如果父区块包含uncle区块，则y为2，如果不包含，则y为1。这样做的主要原因是调整网络的货币发行速度。<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/1b70ea08dbb43c4a47b7263094d9a9a3.svg" alt="image">则是用来评估出块时间快慢的，其中<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/724066adabd3c9923b67662f94718944.svg" alt="image">是本区快的时间戳，<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/37e3fe6a01c8eede66d9ffbc8dc2d48c.svg" alt="image">是父区快的时间戳，这两个时间的单位都是秒。例如假设现在父区块没有包含任何叔块，那么如果现在出块时间为：</p>
<ul>
<li>【1，8】秒，则出块时间过短，我们需要将难度调高一个单位；</li>
<li>【9，17】秒，则出块时间刚刚好，区块难度不变；</li>
<li>【18，26】秒，则出块时间过慢，我们因该调低一个难度单位；</li>
</ul>
<h3 id="pos-权益证明算法">PoS 权益证明算法</h3>
<p>PoW工作量证明因为耗电而一直收到收到诟病，因此有人提出一种基于集体投票的方法，确定产生链中的新区块。但是简单的投票容易受到女巫攻击，一个人可以伪造多个节点，发起多个投票。于是有人提出使用将投票的结果用其手上持有的加密货币比重加权统计结果，例如Alice，Bob，Charly分别持有3，4，5个以太币，那么Alice的投票结果就占最终结果的<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/c73ff2c40694391f5816daa33149a27e.svg" alt="image">。这样统计投票结果就有很多好处，一是可以防御女巫攻击，如果一个人伪造多个节点，但是其在网络中所持有的虚拟货币占比总是固定的。二是如果有人想针对网络发起51%攻击，在攻击前他得大量买入该种类加密货币，这样会让该种类加密货币市值暴涨，这是网络内原先加密货币持有者乐于看到的。同时我们也按照投票的比例来分配收益，例如上例中Alice和Charly都投票给了一个区块，并且这个区块被确认到链上了，那么Alice和Charly都能获取一定收益。</p>
<p>这样也会导致许多问题，例如网络内拥有最多钱的人最容易挖到矿，从而导致富者越富，穷者越穷。因此我们规定，投票是按质押货币来操作的，并且质押过的币一段时间之内都不能再用于质押。同时这样的系统容易遭受Nothing at Stake攻击，矿工在遇到两个分叉的区块时，可以两边同时下注，即便一个区块被抛弃了，矿工异能从另外一个区块获得收益。这样容易造成链的分叉，也会降低分叉攻击的成本。因此我们规定如果有个给一个或者多个区块投票，则他因该收到惩罚。</p>
<p>以太坊所使用的权益证明PoS机制叫Casper：The Friendly Finality Gadget（FFG）。在这个机制中，时间被分为一个一个slot，每一个slot大概占15秒，理想情况下每个slot都要出一个区块。网络内的矿工需要对链中新产生的区块轮流投票，每个区块需要得到网络内<img src="images/%E4%BB%A5%E5%A4%AA%E5%9D%8A/28955ef49943e21c66dc069fc9a1445f.svg" alt="image">的认可才能被附加到区块链上。每个人在选举的时候需要质押一定数量的保证金，如果接下来投票过程中发现有的节点给多个区块都投票了，则需要没收他的保证金。</p>
<h2 id="网络层">网络层</h2>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">网络协议分为两个部分：</font></p>
<ul>
<li><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">发现：建立在用户数据报协议之上，并使新节点能够找到相应节点并连接</font></li>
<li><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">DevP2P：建立在传输控制协议之上，并使节点能够交换信息</font></li>
</ul>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">这两个部分并行作用， 发现协议将新的网络参与者输送到网络中，DevP2P则使它们进行交互。</font></p>
<h3 id="font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-发现-font"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">发现</font></h3>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">发现是在网络中寻找其他节点的过程。 该过程使用一小组引导节点（即地址</font><a target="_blank" rel="noopener" href="https://github.com/ethereum/go-ethereum/blob/master/params/bootnodes.go"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">硬编码</font></a><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">为客户端的节点，以便它们能被立即找到，并将客户端连接至对等点）进行引导。 这些引导节点旨在将新节点引入一组对等点，这是它们唯一的目的。它们不参与普通的客户端任务，例如同步链，仅在第一次使用客户端时使用。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">节点与引导节点交互所使用的协议是 </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">Kademlia</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> 的修改版，它使用</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">分布式散列表</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">共享节点列表。 每个节点都有一版此表格，其中包含连接到最近节点所需的信息。 这个“最近”不是指地理距离，而是由节点 ID 的相似性来界定的。 每个节点的表格都会定期刷新，作为一种安全特性。 例如，在 </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">Discv5</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">中，发现协议节点也可以发送显示客户端支持的子协议的聚合发现服务，以便对等点协调通信所用的协议。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">发现过程从 PING-PONG 游戏开始。 一个成功的 PING-PONG 将新节点“连接”到一个启动节点。 提醒引导节点有新节点进入网络的初始消息为</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;PING&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">。 此</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;PING&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">包括关于新节点、引导节点和过期时间戳的哈希信息。 引导节点接收到</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;PING&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">返回</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;PONG&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">，其中包含</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;PING&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">哈希值。 如果</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;PING&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">和</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;PONG&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">的哈希值相匹配，新节点和引导节点之间的连接就会得到验证，然后就认为它们已经“绑定”。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">绑定之后，新节点即可向引导节点发送</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;FIND-NEIGHBOURS&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">请求。 引导节点返回的数据包含一个新节点可以连接的节点列表。 如果这两个节点没有绑定，</font><code>&lt;font style=&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;FIND-NEIGHBOURS&lt;/font&gt;</code><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);"> </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">请求将失败，新节点将无法进入网络。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">新节点从引导节点收到邻居节点列表后，就会开始与每个邻居节点交换 PING-PONG。 成功的 PING-PONG 将新节点与邻居节点绑定在一起，以实现消息交换。</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动客户端 --&gt; 连接到 bootnode --&gt; 绑定到 bootnode --&gt; 寻找邻居--&gt; 绑定到邻居。</span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">执行客户端目前使用 </font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">Discv4</font><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">发现协议，并且正在积极迁移到 Discv5协议。</font></p>
<h4 id="font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-enr：以太坊节点记录-font"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">ENR：以太坊节点记录</font></h4>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">以太坊节点记录 (ENR) 是一个包含三个基本元素的对象：签名（根据某种商定的身份识别方案创建的记录内容的散列）、跟踪记录更改的序号和键:值对的任意列表。 这种格式不会过时，使新对等点之间身份识别信息的交换更加容易，并且是以太坊节点的首选网络地址格式。</font></p>
<h4 id="font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-发现为什么建立在udp协议上？-font"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">发现为什么建立在UDP协议上？</font></h4>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">UDP协议不支持任何错误检查、重新发送失败的数据包，或者动态地打开和关闭连接；相反，它只是将连续的信息流发送至目标，无论它们是否被对方成功接收。 这种最简化的功能会产生最少的连接开销，从而使这种连接非常迅速。 对于发现而言，如果某个节点只想让其它节点知道它的存在以便它与某个对等点建立正式的连接，UDP协议就已经足够了。 然而，对网络协议栈的其余部分来说，UDP协议就不那么合适了。 节点之间的信息交流相当复杂，因此需要一个功能更完善的协议来支持重新发送、错误检查等。 TCP协议带来更多功能所产生的额外连接开销是值得的。 因此，对等网络协议栈中的大多数协议在TCP协议之上运行。</font></p>
<h3 id="font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-devp2p-font"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">DevP2P</font></h3>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">DevP2P 本身就是以太坊为建立和维护对等网络而实施的一整套协议。 新节点进入网络后，它们的交互由 </font><a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">DevP2P(</font></a><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">堆栈中的协议管控。 这些操作均基于传输控制协议，包括 RLPx 传输协议、线路协议和若干子协议。 </font><a target="_blank" rel="noopener" href="https://github.com/ethereum/devp2p/blob/master/rlpx.md"><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">RLPx</font></a><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">是管理启动、验证和维护节点之间会话的协议。 使用 RLP（递归长前缀）的 RLPx 对消息进行编码。递归长度前缀是一种非常节省空间的编码方法，可将数据编码成最小结构，以便在节点之间发送。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">两个节点之间的 RLPx 会话始于初始的加密握手。 这需要节点发送身份验证消息，然后等待对方进行验证。 成功验证后，对方会生成身份确认信息，并将信息返回初始节点。 这是一个密钥交换过程，使节点能够私下安全地进行沟通。 成功的加密握手会触发两个节点“在线”互相发送“hello”消息。 线路协议则通过成功地交换“hello”信息发起。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">Hello 消息包含：</font></p>
<ul>
<li><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">协议版本</font></li>
<li><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">客戶端 ID</font></li>
<li><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">端口</font></li>
<li><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">节点 ID</font></li>
<li><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">支持的子协议列表</font></li>
</ul>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">成功交互需要这些信息，因为它们定义节点之间共享的能力并配置通信。 另外还有个子协议协调过程，届时会将每个节点支持的子协议列表进行对比，并能将两个节点共用的子协议用于会话。</font></p>
<p><font style="color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);">除了“hello”消息之外，线路协议还可以发送一个“disconnect”消息，以警告对等点连接将被断开。 线路协议还包含定期发送的 PING 和 PONG 消息，以使会话保持开放。 因此，RLPx 和线路协议之间信息交换为节点之间的通信奠定了基础，并为根据特定子协议交换有用的信息提供了平台。</font></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Nie-Tianyi.github.io">nty</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://nie-tianyi.github.io/2024/07/28/%E4%BB%A5%E5%A4%AA%E5%9D%8A_preprocessed/">https://nie-tianyi.github.io/2024/07/28/%E4%BB%A5%E5%A4%AA%E5%9D%8A_preprocessed/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://Nie-Tianyi.github.io" target="_blank">nty的技术博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/">以太坊</a><a class="post-meta__tags" href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/">智能合约</a></div><div class="post-share"><div class="social-share" data-image="/images/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/07/28/%E4%BA%8C%E5%B1%82%E6%89%A9%E5%B1%95_preprocessed/" title="二层扩展"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">二层扩展</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/09/03/%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE_preprocessed/" title="共识协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">共识协议</div></div><div class="info-2"><div class="info-item-1">介绍 共识协议是保证区块链中保证多台计算机（分布式系统）在存在网络延迟的情况下，仍然能保证状态一致的算法。分布式系统中的共识协议根据解决问题的不同可以分为两大类，一种是崩溃容错协议（Crash Fault Tolerance, CFT）,另一种是拜占庭容错协议（Byzantine Fault Tolerance,...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/28/%E4%BA%8C%E5%B1%82%E6%89%A9%E5%B1%95_preprocessed/" title="二层扩展"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-28</div><div class="info-item-2">二层扩展</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/09/03/%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE_preprocessed/" title="共识协议"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-03</div><div class="info-item-2">共识协议</div></div><div class="info-2"><div class="info-item-1">介绍 共识协议是保证区块链中保证多台计算机（分布式系统）在存在网络延迟的情况下，仍然能保证状态一致的算法。分布式系统中的共识协议根据解决问题的不同可以分为两大类，一种是崩溃容错协议（Crash Fault Tolerance, CFT）,另一种是拜占庭容错协议（Byzantine Fault Tolerance,...</div></div></div></a><a class="pagination-related" href="/2024/07/14/%E6%AF%94%E7%89%B9%E5%B8%81_preprocessed/" title="比特币"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-14</div><div class="info-item-2">比特币</div></div><div class="info-2"><div class="info-item-1">密码学基础 现代密码学中，我们通常要求一个加密的系统满足一下几点要求（CIA）：  Confidentiality，保密性，及信息不能泄露给不应该知道这个信息的人。 Integrity，完整性，及数据在传输的过程中不能被篡改，如果被篡改，通信双方应该立马能发现。 Accessiblity，可通达性，及系统应该免于DDos等攻击，通信双方可以保持通信畅通。 （也有说Authority的，权威性，及保证信息来源真实可信）  现代密码学和密码加密技术通常被分为两类：对称加密和非对称加密。对称加密是指用于加密和解密的密钥是一样的，对称加密中加密和解密通常是“对称”的操作。非对称加密中，加密和解密的密钥是不一样的。非对称加密中，存在一对密钥，其中一个用于加密，另一个用于解密。用其中一个密钥加密的信息，只能用另一个密钥解密，而反过来用另一个密钥加密的信息，也只能由当前密钥解密。 对称加密中又通常分为流加密（stream cipher）和块加密（block cipher），常见的流加密算法有chacha20。chacha20 中，通过一段固定的伪随机 2...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">nty</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Nie-Tianyi"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">用户层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A6%E6%88%B7%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">账户结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%98%93%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">交易层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-data-font-font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-%E5%AD%97%E6%AE%B5-font"><span class="toc-number">2.1.</span> <span class="toc-text">&lt;font style&#x3D;&quot;color:rgb(27, 27, 27);background-color:rgb(247, 247, 247);&quot;&gt;data&lt;&#x2F;font&gt;字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-%E4%BA%A4%E6%98%93%E7%B1%BB%E5%9E%8B-font"><span class="toc-number">2.2.</span> <span class="toc-text">交易类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-bloom-filter"><span class="toc-number">2.3.</span> <span class="toc-text">布隆过滤器 Bloom Filter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">合约层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#solidity"><span class="toc-number">3.1.</span> <span class="toc-text">Solidity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E7%9A%84%E6%94%BB%E5%87%BB"><span class="toc-number">3.2.</span> <span class="toc-text">针对智能合约的攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">重入攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB"><span class="toc-number">3.2.2.</span> <span class="toc-text">溢出攻击</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">执行层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#evm"><span class="toc-number">4.1.</span> <span class="toc-text">EVM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A6%E6%9C%AC%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text">账本层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mpt%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">5.1.</span> <span class="toc-text">MPT的构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text">状态树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%91"><span class="toc-number">5.3.</span> <span class="toc-text">交易树和收据树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E8%AF%86%E5%B1%82"><span class="toc-number">6.</span> <span class="toc-text">共识层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ghost%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.1.</span> <span class="toc-text">GHOST协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8Aghost%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.2.</span> <span class="toc-text">以太坊GHOST协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%AD%E7%9A%84pow%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">以太坊中的PoW算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#asic-resistant-pow-%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">ASIC-Resistant PoW 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pos-%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E%E7%AE%97%E6%B3%95"><span class="toc-number">6.5.</span> <span class="toc-text">PoS 权益证明算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">7.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-%E5%8F%91%E7%8E%B0-font"><span class="toc-number">7.1.</span> <span class="toc-text">发现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-enr%EF%BC%9A%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%8A%82%E7%82%B9%E8%AE%B0%E5%BD%95-font"><span class="toc-number">7.1.1.</span> <span class="toc-text">ENR：以太坊节点记录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-%E5%8F%91%E7%8E%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E7%AB%8B%E5%9C%A8udp%E5%8D%8F%E8%AE%AE%E4%B8%8A%EF%BC%9F-font"><span class="toc-number">7.1.2.</span> <span class="toc-text">发现为什么建立在UDP协议上？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#font-style-color-rgb-27-27-27-background-color-rgb-247-247-247-devp2p-font"><span class="toc-number">7.2.</span> <span class="toc-text">DevP2P</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/14/%E4%BB%80%E4%B9%88%E6%98%AFHadoop_preprocessed/" title="Hadoop">Hadoop</a><time datetime="2025-09-14T12:46:25.000Z" title="发表于 2025-09-14 20:46:25">2025-09-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/12/Raft%E5%8D%8F%E8%AE%AE_preprocessed/" title="Raft协议">Raft协议</a><time datetime="2025-09-12T12:46:25.000Z" title="发表于 2025-09-12 20:46:25">2025-09-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/09/07/%E5%87%B8%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96%E4%B8%80_preprocessed/" title="凸函数优化笔记（1）">凸函数优化笔记（1）</a><time datetime="2025-09-07T12:46:25.000Z" title="发表于 2025-09-07 20:46:25">2025-09-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/27/%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89_preprocessed/" title="线性函数定义">线性函数定义</a><time datetime="2025-08-27T12:46:25.000Z" title="发表于 2025-08-27 20:46:25">2025-08-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/16/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A2%AF%E5%BA%A6%E6%8E%A8%E5%AF%BC_preprocessed/" title="神经网络's Gradient">神经网络's Gradient</a><time datetime="2025-08-16T12:46:25.000Z" title="发表于 2025-08-16 20:46:25">2025-08-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By nty</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>